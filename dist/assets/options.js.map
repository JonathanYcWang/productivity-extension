{"version":3,"file":"options.js","sources":["../../src/components/CardGamble.tsx","../../src/components/BlockedSitesSection.tsx","../../src/components/TimeWindowsSection.tsx","../../src/components/MasterSwitchSection.tsx","../../src/components/ResetSection.tsx","../../src/components/FocusTimerSection.tsx","../../src/options/App.tsx"],"sourcesContent":["import React from \"react\";\nimport \"../styles/CardGamble.css\";\nimport { TemporaryUnblock, Settings } from \"../types\";\nimport { storage, runtime } from \"../lib/browser-api\";\n\ninterface CardGambleProps {\n  domains: string[];\n  domainDurations?: Record<string, number[]>; // durations in minutes for each domain\n  resetKey?: number; // When this changes, reset all state\n}\n\ninterface CardOption {\n  type: 'domain' | 'bonusRerolls';\n  domain?: string;\n  durationMinutes?: number;\n  bonusRerolls?: number; // 1, 2, or 3\n}\n\n// Extract just the hostname from a domain string\nfunction extractHostname(domain: string): string {\n  try {\n    // Remove protocol if present\n    let hostname = domain.replace(/^https?:\\/\\//i, '');\n    // Remove path, query strings, and fragments\n    hostname = hostname.split('/')[0].split('?')[0].split('#')[0];\n    // Remove port if present\n    hostname = hostname.split(':')[0];\n    // Remove www. prefix\n    hostname = hostname.replace(/^www\\./i, '');\n    // Trim whitespace\n    hostname = hostname.trim();\n    return hostname;\n  } catch {\n    // If parsing fails, just clean up the string\n    return domain\n      .replace(/^https?:\\/\\//i, '')\n      .replace(/\\/.*$/, '')\n      .replace(/\\?.*$/, '')\n      .replace(/#.*$/, '')\n      .replace(/:.*$/, '')\n      .replace(/^www\\./i, '')\n      .trim();\n  }\n}\n\n// Generate a random option - domain or bonus reroll card\n// Bonus rerolls have 10% chance, domains have 90% chance (distributed equally)\nfunction generateRandomOption(\n  domains: string[],\n  domainDurations: Record<string, number[]>\n): CardOption {\n  if (domains.length === 0) {\n    // If no domains, return bonus reroll\n    return { type: 'bonusRerolls', bonusRerolls: 1 };\n  }\n\n  // 10% chance for bonus reroll, 90% chance for domain\n  const random = Math.random();\n  if (random < 0.1) {\n    // Generate a bonus reroll card (always 1 reroll)\n    return {\n      type: 'bonusRerolls',\n      bonusRerolls: 1\n    };\n  } else {\n    // Generate a domain card (90% chance, distributed equally among domains)\n    const randomIndex = Math.floor(Math.random() * domains.length);\n    const randomDomain = domains[randomIndex];\n    const customDurations = domainDurations[randomDomain] || [];\n    \n    let unblockMinutes: number;\n    if (customDurations.length > 0) {\n      const durationIndex = Math.floor(Math.random() * customDurations.length);\n      unblockMinutes = customDurations[durationIndex];\n    } else {\n      // Default: random duration between 5 minutes and 2 hours\n      const minMinutes = 5;\n      const maxMinutes = 120;\n      unblockMinutes = Math.floor(Math.random() * (maxMinutes - minMinutes + 1)) + minMinutes;\n    }\n\n    return {\n      type: 'domain',\n      domain: randomDomain,\n      durationMinutes: unblockMinutes\n    };\n  }\n}\n\nconst REROLL_STATE_KEY = \"cardGambleRerollState\";\n\ninterface RerollState {\n  availableRerolls: number; // Track available rerolls directly (can exceed initial)\n  rerollResetTime: number | null;\n  rerollResetTimePaused: number | null; // Remaining time when paused\n  lastCardGeneration: number; // timestamp when cards were last generated\n  cards: CardOption[]; // Current cards displayed\n  selectedCard: number | null; // Which card is selected\n  cardsLocked: boolean; // Whether cards are locked\n  showCards: boolean; // Whether cards are showing\n  animationKey: number; // Animation key for card animations\n  selectedCardExpiresAt: number | null; // When the selected domain card expires\n}\n\nconst MIN_REROLL_RESET_MINUTES = 30;\nconst MAX_REROLL_RESET_MINUTES = 60;\nconst INITIAL_REROLLS = 3; // Starting number of rerolls\n\n// Generate random reset time between MIN and MAX minutes\nfunction generateRandomResetTime(): number {\n  const minutes = Math.floor(Math.random() * (MAX_REROLL_RESET_MINUTES - MIN_REROLL_RESET_MINUTES + 1)) + MIN_REROLL_RESET_MINUTES;\n  return Date.now() + (minutes * 60 * 1000);\n}\n\nexport function CardGamble({ domains, domainDurations = {}, resetKey }: CardGambleProps) {\n  const [cards, setCards] = React.useState<CardOption[]>([]);\n  const [showCards, setShowCards] = React.useState(false);\n  const [selectedCard, setSelectedCard] = React.useState<number | null>(null);\n  const [animationKey, setAnimationKey] = React.useState(0);\n  const [availableRerolls, setAvailableRerolls] = React.useState(INITIAL_REROLLS);\n  const [rerollResetTime, setRerollResetTime] = React.useState<number | null>(null);\n  const [rerollResetTimePaused, setRerollResetTimePaused] = React.useState<number | null>(null); // Remaining time when paused\n  const [timeRemaining, setTimeRemaining] = React.useState<number>(0);\n  const [isLoadingState, setIsLoadingState] = React.useState(true);\n  const [cardsLocked, setCardsLocked] = React.useState(false);\n  const [selectedCardExpiresAt, setSelectedCardExpiresAt] = React.useState<number | null>(null);\n  const [unblockTimeRemaining, setUnblockTimeRemaining] = React.useState<number>(0);\n  const [canceledCardIndex, setCanceledCardIndex] = React.useState<number | null>(null);\n  const [cardAnimationKeys, setCardAnimationKeys] = React.useState<number[]>([0, 0, 0]); // Per-card animation keys\n  const [isFocusTimeActive, setIsFocusTimeActive] = React.useState(false);\n\n  // Check focus time status\n  React.useEffect(() => {\n    const checkFocusTime = async () => {\n      try {\n        const { settings } = await storage.sync.get('settings');\n        if (settings) {\n          const mode = settings.mode || 'scheduled';\n          // Focus time is active if mode is 'focus' and either:\n          // - focusTimeEnd is set (timer is running)\n          // - focusTimePaused is set (timer is paused but was active)\n          const isActive = mode === 'focus' && \n            (settings.focusTimeEnd || (settings.focusTimePaused && settings.focusTimePaused > 0));\n          setIsFocusTimeActive(isActive);\n        }\n      } catch (error) {\n        console.error('Error checking focus time:', error);\n      }\n    };\n    \n    checkFocusTime();\n    \n    // Listen for storage changes to detect focus time start\n    if (storage.onChanged) {\n      const listener = (changes: any, area: string) => {\n        if (area === \"sync\" && changes.settings) {\n          const newSettings = changes.settings.newValue;\n          if (newSettings) {\n            const mode = newSettings.mode || 'scheduled';\n            // Focus time is active if mode is 'focus' and either:\n            // - focusTimeEnd is set (timer is running)\n            // - focusTimePaused is set (timer is paused but was active)\n            const isActive = mode === 'focus' && \n              (newSettings.focusTimeEnd || (newSettings.focusTimePaused && newSettings.focusTimePaused > 0));\n            setIsFocusTimeActive(isActive);\n          }\n        }\n      };\n      \n      storage.onChanged.addListener(listener);\n      return () => {\n        if (storage.onChanged && 'removeListener' in storage.onChanged) {\n          (storage.onChanged as any).removeListener(listener);\n        }\n      };\n    }\n  }, []);\n\n  // Load persisted reroll state\n  React.useEffect(() => {\n    const loadRerollState = async () => {\n      try {\n        const { [REROLL_STATE_KEY]: state } = await storage.local.get(REROLL_STATE_KEY);\n        if (state) {\n          const rerollState: RerollState = state;\n          const now = Date.now();\n          \n          // Check if timer has expired\n          if (rerollState.rerollResetTime && rerollState.rerollResetTime <= now) {\n            // Timer expired, reset rerolls\n            setAvailableRerolls(INITIAL_REROLLS);\n            setRerollResetTime(null);\n            setCardsLocked(false); // Unlock cards\n            setSelectedCard(null); // Clear selection\n            await storage.local.remove(REROLL_STATE_KEY);\n            // Cards will be regenerated by the initialization effect\n          } else {\n            // Load persisted state\n            setAvailableRerolls(rerollState.availableRerolls ?? INITIAL_REROLLS);\n            setRerollResetTime(rerollState.rerollResetTime);\n            setRerollResetTimePaused(rerollState.rerollResetTimePaused ?? null);\n            \n            // Load card state if it exists\n            if (rerollState.cards && rerollState.cards.length > 0) {\n              setCards(rerollState.cards);\n              setSelectedCard(rerollState.selectedCard ?? null);\n              setCardsLocked(rerollState.cardsLocked ?? false);\n              setShowCards(rerollState.showCards ?? true);\n              setAnimationKey(rerollState.animationKey ?? 0);\n              \n              // Try to restore expiration time from persisted state or active unblocks\n              if (rerollState.selectedCardExpiresAt) {\n                setSelectedCardExpiresAt(rerollState.selectedCardExpiresAt);\n              } else if (rerollState.selectedCard !== null && rerollState.selectedCard !== undefined) {\n                // If we have a selected card but no expiration time, try to get it from active unblocks\n                const selectedCardData = rerollState.cards[rerollState.selectedCard];\n                if (selectedCardData && selectedCardData.type === 'domain' && selectedCardData.domain) {\n                  try {\n                    const response = await runtime.sendMessage({ action: 'getActiveUnblocks' });\n                    if (response && response.success && response.unblocks) {\n                      const normalizedDomain = extractHostname(selectedCardData.domain).toLowerCase();\n                      const matchingUnblock = response.unblocks.find((u: TemporaryUnblock) => \n                        extractHostname(u.domain).toLowerCase() === normalizedDomain\n                      );\n                      if (matchingUnblock) {\n                        setSelectedCardExpiresAt(matchingUnblock.expiresAt);\n                      }\n                    }\n                  } catch (error) {\n                    console.error('Error fetching active unblocks on load:', error);\n                  }\n                }\n              }\n            }\n            \n            // If timer is running, cards should be locked\n            // (a card was selected and we're waiting for timer to reset)\n            if (rerollState.rerollResetTime && rerollState.rerollResetTime > now) {\n              setCardsLocked(true);\n            }\n            \n            // If timer is still active, notify background script\n            if (rerollState.rerollResetTime && rerollState.rerollResetTime > now) {\n              try {\n                runtime.sendMessage({\n                  action: 'scheduleRerollReset',\n                  resetTime: rerollState.rerollResetTime\n                });\n              } catch (error) {\n                console.error('Error scheduling reroll reset:', error);\n              }\n            }\n          }\n        } else {\n          // No persisted state - check if focus time is active before initializing timer\n          const checkAndInitialize = async () => {\n            try {\n              const { settings } = await storage.sync.get('settings');\n              const mode = settings?.mode || 'scheduled';\n              // Focus time is active if mode is 'focus' and either:\n              // - focusTimeEnd is set (timer is running)\n              // - focusTimePaused is set (timer is paused but was active)\n              const focusActive = mode === 'focus' && \n                (settings?.focusTimeEnd || (settings?.focusTimePaused && settings.focusTimePaused > 0));\n              \n              if (focusActive) {\n                // Focus time is active - start timer\n                const initialResetTime = generateRandomResetTime();\n                setRerollResetTime(initialResetTime);\n                setAvailableRerolls(INITIAL_REROLLS);\n                setCardsLocked(true); // Lock cards until timer expires\n                setShowCards(false); // Don't show cards initially\n                \n                // Notify background script to schedule the alarm\n                try {\n                  await runtime.sendMessage({\n                    action: 'scheduleRerollReset',\n                    resetTime: initialResetTime\n                  });\n                } catch (error) {\n                  console.error('Error scheduling initial reroll reset:', error);\n                }\n              } else {\n                // Focus time not active - keep cards locked, no timer\n                setAvailableRerolls(INITIAL_REROLLS);\n                setCardsLocked(true);\n                setShowCards(false);\n                setRerollResetTime(null);\n              }\n            } catch (error) {\n              console.error('Error checking focus time for initialization:', error);\n            }\n          };\n          \n          checkAndInitialize();\n        }\n      } catch (error) {\n        console.error('Error loading reroll state:', error);\n      } finally {\n        setIsLoadingState(false);\n      }\n    };\n    \n    loadRerollState();\n  }, []);\n\n  // Save reroll state whenever it changes\n  React.useEffect(() => {\n    if (isLoadingState) return; // Don't save during initial load\n    \n    const saveRerollState = async () => {\n      try {\n        const state: RerollState = {\n          availableRerolls,\n          rerollResetTime,\n          rerollResetTimePaused,\n          lastCardGeneration: Date.now(),\n          cards,\n          selectedCard,\n          cardsLocked,\n          showCards,\n          animationKey,\n          selectedCardExpiresAt\n        };\n        await storage.local.set({ [REROLL_STATE_KEY]: state });\n      } catch (error) {\n        console.error('Error saving reroll state:', error);\n      }\n    };\n    \n    saveRerollState();\n  }, [availableRerolls, rerollResetTime, rerollResetTimePaused, cards, selectedCard, cardsLocked, showCards, animationKey, selectedCardExpiresAt, isLoadingState]);\n\n  // Reset all state when resetKey changes\n  React.useEffect(() => {\n    if (resetKey === undefined) return; // Don't reset on initial mount\n    \n    const resetAll = async () => {\n      // Reset all state\n      setAvailableRerolls(INITIAL_REROLLS);\n      setRerollResetTime(null);\n      setCardsLocked(false);\n      setSelectedCard(null);\n      setTimeRemaining(0);\n      setSelectedCardExpiresAt(null);\n      setCanceledCardIndex(null);\n      setRerollResetTimePaused(null);\n      \n      // Clear persisted state\n      await storage.local.remove(REROLL_STATE_KEY);\n      \n      // Cancel any scheduled alarms\n      try {\n        runtime.sendMessage({\n          action: 'cancelRerollReset'\n        });\n      } catch (error) {\n        console.error('Error canceling reroll reset:', error);\n      }\n      \n      // Regenerate cards\n      if (domains.length > 0) {\n        const newCards = Array.from({ length: 3 }, () => \n          generateRandomOption(domains, domainDurations)\n        );\n        setCards(newCards);\n        setCardAnimationKeys([0, 0, 0]); // Reset per-card animation keys\n        setAnimationKey(prev => prev + 1);\n        setShowCards(false);\n        setTimeout(() => {\n          setShowCards(true);\n        }, 50);\n      }\n    };\n    \n    resetAll();\n  }, [resetKey]); // Only reset when resetKey changes, not when domains change\n\n  // Note: Cards are now generated in the timer countdown effect when timer expires\n  // This effect is kept for backward compatibility but cards should be generated by timer expiration\n\n  // Start timer when focus time becomes active (only on initial start)\n  // Timer also starts when card expires/cancels (handled by resumeRerollTimer)\n  React.useEffect(() => {\n    if (isFocusTimeActive && !rerollResetTime && !selectedCardExpiresAt && !isLoadingState) {\n      // Start timer on initial focus time start\n      // Only skip if timer just expired (cards exist and are unlocked - waiting for selection)\n      // Check if cards exist and are unlocked - clear sign timer just expired\n      const timerJustExpired = !cardsLocked && cards.length > 0;\n      if (!timerJustExpired) {\n        // Focus time just started - start the initial timer\n        const initialResetTime = generateRandomResetTime();\n        setRerollResetTime(initialResetTime);\n        setCardsLocked(true); // Lock cards until timer expires\n        setShowCards(false);\n        setCards([]); // Clear any existing cards\n        setAvailableRerolls(INITIAL_REROLLS);\n        \n        // Notify background script to schedule the alarm\n        runtime.sendMessage({\n          action: 'scheduleRerollReset',\n          resetTime: initialResetTime\n        }).catch(error => {\n          console.error('Error scheduling reroll reset:', error);\n        });\n      }\n      // If cards exist and are unlocked (timer just expired), don't start timer - wait for selection\n    } else if (!isFocusTimeActive) {\n      // Focus time stopped - clear timer and lock cards\n      if (rerollResetTime && !selectedCardExpiresAt) {\n        setRerollResetTime(null);\n        setRerollResetTimePaused(null);\n        \n        // Cancel the scheduled alarm\n        runtime.sendMessage({\n          action: 'cancelRerollReset'\n        }).catch(error => {\n          console.error('Error canceling reroll reset:', error);\n        });\n      }\n      // Always lock cards and clear them when focus time is not active (unless a card is selected)\n      if (selectedCard === null) {\n        setCardsLocked(true);\n        setShowCards(false);\n        setCards([]);\n        setTimeRemaining(0);\n      }\n    }\n  }, [isFocusTimeActive, rerollResetTime, selectedCardExpiresAt, isLoadingState, cardsLocked, cards.length, selectedCard]);\n\n  // Timer countdown effect\n  React.useEffect(() => {\n    // Don't run timer if focus time is not active\n    if (!isFocusTimeActive) {\n      setTimeRemaining(0);\n      // Keep cards locked if focus time is not active\n      if (!rerollResetTime) {\n        setCardsLocked(true);\n      }\n      return;\n    }\n    \n    // If a card is selected and timer is active, pause the re-roll timer\n    if (selectedCardExpiresAt && selectedCard !== null) {\n      // Timer is paused - don't show timer while card is active\n      setTimeRemaining(0);\n      return; // Don't run countdown while card timer is active\n    }\n\n    // If no timer is running and cards are unlocked, stop the timer display\n    if (!rerollResetTime) {\n      setTimeRemaining(0);\n      // Only lock cards if they're not already unlocked (i.e., waiting for initial timer to start)\n      // Don't lock cards if timer expired and cards should be selectable\n      if (cardsLocked && cards.length === 0) {\n        // Waiting for initial timer to start\n        setCardsLocked(true);\n      }\n      return;\n    }\n\n    // Timer is active - keep cards locked while timer is running\n    setCardsLocked(true);\n\n    const updateTimer = () => {\n      const now = Date.now();\n      const remaining = Math.max(0, rerollResetTime - now);\n      setTimeRemaining(remaining);\n\n      if (remaining === 0) {\n        // Timer expired - unlock cards and generate them, stop the timer\n        setAvailableRerolls(INITIAL_REROLLS);\n        setRerollResetTime(null);\n        setRerollResetTimePaused(null);\n        setTimeRemaining(0); // Explicitly set to 0 to stop timer display\n        setCardsLocked(false); // Unlock cards when timer expires\n        setSelectedCard(null); // Clear selection - reset all cards\n        setSelectedCardExpiresAt(null);\n        setCanceledCardIndex(null);\n        \n        // Pause focus timer when cards become selectable\n        const pauseFocusTimerForCardSelection = async () => {\n          try {\n            const { settings } = await storage.sync.get('settings');\n            if (settings && settings.mode === 'focus' && settings.focusTimeEnd) {\n              const now = Date.now();\n              const remaining = Math.max(0, settings.focusTimeEnd - now);\n              if (remaining > 0) {\n                // Pause focus timer by storing remaining time\n                await storage.sync.set({\n                  settings: {\n                    ...settings,\n                    focusTimePaused: remaining,\n                    focusTimeEnd: undefined // Clear end time to pause\n                  }\n                });\n              }\n            }\n          } catch (error) {\n            console.error('Error pausing focus timer for card selection:', error);\n          }\n        };\n        pauseFocusTimerForCardSelection();\n        \n        // Switch to options page when cards become selectable\n        runtime.openOptionsPage().catch(error => {\n          console.error('Error opening options page:', error);\n        });\n        \n        // Generate cards for new round (or initial cards if none exist)\n        if (domains.length > 0) {\n          const newCards = Array.from({ length: 3 }, () => \n            generateRandomOption(domains, domainDurations)\n          );\n          setCards(newCards);\n          setCardAnimationKeys([0, 0, 0]); // Reset per-card animation keys\n          setAnimationKey(prev => prev + 1);\n          setShowCards(false);\n          setTimeout(() => {\n            setShowCards(true);\n          }, 50);\n        }\n        // Clear persisted state\n        storage.local.remove(REROLL_STATE_KEY).catch(console.error);\n      }\n    };\n\n    updateTimer();\n    const interval = setInterval(updateTimer, 1000);\n\n    return () => clearInterval(interval);\n  }, [isFocusTimeActive, rerollResetTime, rerollResetTimePaused, selectedCardExpiresAt, selectedCard, availableRerolls, domains, domainDurations, cardsLocked, cards.length]);\n\n  const rerollCard = (cardIndex: number) => {\n    // Check if user has any available rerolls\n    if (availableRerolls <= 0) return;\n\n    // Trigger animation by incrementing the animation key for this specific card\n    setCardAnimationKeys(prev => {\n      const newKeys = [...prev];\n      newKeys[cardIndex] = (newKeys[cardIndex] || 0) + 1;\n      return newKeys;\n    });\n\n    // Small delay to allow animation to start, then update the card\n    setTimeout(() => {\n      setCards(prevCards => {\n        const newCards = [...prevCards];\n        newCards[cardIndex] = generateRandomOption(domains, domainDurations);\n        return newCards;\n      });\n    }, 50);\n\n    setAvailableRerolls(prev => prev - 1);\n    // Timer is started when a card is selected, not when rerolls are used\n  };\n\n  const selectCard = async (cardIndex: number) => {\n    if (selectedCard !== null || cardsLocked) return; // Already selected or cards are locked\n    \n    const card = cards[cardIndex];\n    if (!card) return;\n\n    if (card.type === 'bonusRerolls' && card.bonusRerolls) {\n      // Bonus reroll card - add rerolls to the pool and replace this card\n      setAvailableRerolls(prev => prev + card.bonusRerolls!);\n      \n      // Replace only this card with a new random card, keep others unchanged\n      setCards(prevCards => {\n        const newCards = [...prevCards];\n        newCards[cardIndex] = generateRandomOption(domains, domainDurations);\n        return newCards;\n      });\n      \n      // Don't lock cards or start timer for bonus reroll cards\n      return;\n    }\n    \n    // For domain cards, lock cards, reset rerolls, and pause/clear any existing timer\n    setSelectedCard(cardIndex);\n    setCardsLocked(true); // Lock all cards after selection\n    setAvailableRerolls(0); // Lose all rerolls when a domain card is selected\n    \n    // Pause re-roll timer if it's running - don't start a new one\n    // Timer will only start after the selected card's timer finishes\n    if (rerollResetTime) {\n      const now = Date.now();\n      const remaining = Math.max(0, rerollResetTime - now);\n      if (remaining > 0) {\n        setRerollResetTimePaused(remaining);\n        setRerollResetTime(null); // Clear active timer to pause it\n        \n        // Cancel the scheduled alarm\n        try {\n          await runtime.sendMessage({\n            action: 'cancelRerollReset'\n          });\n        } catch (error) {\n          console.error('Error canceling reroll reset:', error);\n        }\n      }\n    } else {\n      // Clear any paused timer - timer will start fresh after card expires\n      setRerollResetTimePaused(null);\n    }\n    \n    if (card.type === 'domain' && card.domain && card.durationMinutes) {\n      // Domain card - unblock the domain\n      const expiresAt = Date.now() + (card.durationMinutes * 60 * 1000);\n      setSelectedCardExpiresAt(expiresAt);\n      \n      // Pause focus timer if it's active\n      try {\n        const { settings } = await storage.sync.get('settings');\n        if (settings && settings.mode === 'focus' && settings.focusTimeEnd) {\n          const now = Date.now();\n          const remaining = Math.max(0, settings.focusTimeEnd - now);\n          if (remaining > 0) {\n            // Pause focus timer by storing remaining time\n            await storage.sync.set({\n              settings: {\n                ...settings,\n                focusTimePaused: remaining,\n                focusTimeEnd: undefined // Clear end time to pause\n              }\n            });\n          }\n        }\n      } catch (error) {\n        console.error('Error pausing focus timer:', error);\n      }\n      \n      // Send message to background script to temporarily unblock this domain\n      try {\n        await runtime.sendMessage({\n          action: 'temporaryUnblock',\n          domain: card.domain,\n          expiresAt: expiresAt,\n          durationMinutes: card.durationMinutes\n        });\n        \n        // Timer and cards remain locked until timer resets - don't clear selectedCard or cardsLocked\n      } catch (error) {\n        console.error('Error sending unblock message:', error);\n      }\n    }\n  };\n\n  // Update unblock countdown for selected card\n  React.useEffect(() => {\n    if (!selectedCardExpiresAt) {\n      setUnblockTimeRemaining(0);\n      return;\n    }\n\n    const updateCountdown = () => {\n      const now = Date.now();\n      const remaining = Math.max(0, selectedCardExpiresAt - now);\n      setUnblockTimeRemaining(remaining);\n      \n      // If expired, automatically disable the card\n      if (remaining === 0 && selectedCard !== null) {\n        const canceledIndex = selectedCard;\n        setCanceledCardIndex(canceledIndex);\n        setSelectedCard(null);\n        setSelectedCardExpiresAt(null);\n        \n        // Resume focus timer if it was paused\n        resumeFocusTimer();\n        // Start new next selection timer (this will lock cards, clear them, and start countdown)\n        resumeRerollTimer();\n      }\n    };\n\n    updateCountdown();\n    const interval = setInterval(updateCountdown, 1000);\n    return () => clearInterval(interval);\n  }, [selectedCardExpiresAt, selectedCard]);\n\n  // Format time remaining as MM:SS\n  const formatTimeRemaining = (ms: number): string => {\n    if (ms <= 0) return '00:00';\n    const totalSeconds = Math.floor(ms / 1000);\n    const minutes = Math.floor(totalSeconds / 60);\n    const seconds = totalSeconds % 60;\n    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;\n  };\n\n  // Format unblock time remaining in a readable format\n  const formatUnblockCountdown = (ms: number): string => {\n    if (ms <= 0) return 'Expired';\n    \n    const totalSeconds = Math.floor(ms / 1000);\n    const hours = Math.floor(totalSeconds / 3600);\n    const minutes = Math.floor((totalSeconds % 3600) / 60);\n    const seconds = totalSeconds % 60;\n    \n    if (hours > 0) {\n      return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;\n    }\n    return `${minutes}:${seconds.toString().padStart(2, '0')}`;\n  };\n\n  // Resume focus timer if it was paused\n  const resumeFocusTimer = async () => {\n    try {\n      const { settings } = await storage.sync.get('settings');\n      if (settings && settings.mode === 'focus' && settings.focusTimePaused) {\n        const now = Date.now();\n        const newEndTime = now + settings.focusTimePaused;\n        await storage.sync.set({\n          settings: {\n            ...settings,\n            focusTimeEnd: newEndTime,\n            focusTimePaused: undefined // Clear paused state\n          }\n        });\n      }\n    } catch (error) {\n      console.error('Error resuming focus timer:', error);\n    }\n  };\n\n  // Resume re-roll timer if it was paused, or start a new one if no timer was paused\n  // This locks cards, clears them, and starts the next selection timer\n  const resumeRerollTimer = () => {\n    // Lock cards and clear them - new timer is starting\n    setCardsLocked(true);\n    setShowCards(false);\n    setCards([]);\n    setAvailableRerolls(INITIAL_REROLLS);\n    setCanceledCardIndex(null);\n    \n    if (rerollResetTimePaused !== null && rerollResetTimePaused > 0) {\n      // Resume the paused timer\n      const now = Date.now();\n      const newResetTime = now + rerollResetTimePaused;\n      setRerollResetTime(newResetTime);\n      setRerollResetTimePaused(null);\n      \n      // Notify background script to schedule the alarm\n      runtime.sendMessage({\n        action: 'scheduleRerollReset',\n        resetTime: newResetTime\n      }).catch(error => {\n        console.error('Error scheduling reroll reset:', error);\n      });\n    } else {\n      // No paused timer - start a new one after card expires\n      const newResetTime = generateRandomResetTime();\n      setRerollResetTime(newResetTime);\n      setRerollResetTimePaused(null);\n      \n      // Notify background script to schedule the alarm\n      runtime.sendMessage({\n        action: 'scheduleRerollReset',\n        resetTime: newResetTime\n      }).catch(error => {\n        console.error('Error scheduling reroll reset:', error);\n      });\n    }\n  };\n\n  // Handle canceling the selected card's unblock\n  const handleCancelUnblock = async () => {\n    if (selectedCard === null) return;\n    \n    const card = cards[selectedCard];\n    if (!card || card.type !== 'domain' || !card.domain) return;\n\n    try {\n      // Cancel the temporary unblock\n      await runtime.sendMessage({ \n        action: 'cancelTemporaryUnblock', \n        domain: card.domain \n      });\n      \n      // Set timer to zero immediately\n      setUnblockTimeRemaining(0);\n      \n      // Change card from selected to disabled state\n      const canceledIndex = selectedCard;\n      setCanceledCardIndex(canceledIndex);\n      setSelectedCard(null);\n      setSelectedCardExpiresAt(null);\n      \n      // Resume focus timer if it was paused\n      resumeFocusTimer();\n      // Start new next selection timer (this will lock cards, clear them, and start countdown)\n      resumeRerollTimer();\n    } catch (error) {\n      console.error('Error canceling unblock:', error);\n    }\n  };\n\n\n  if (domains.length === 0) return null;\n\n  const canReroll = availableRerolls > 0;\n\n  return (\n    <div className=\"card-gamble-container\">\n      <h2>Gamble for Unblock Time</h2>\n      <p className=\"card-gamble-description\">\n        Three cards will drop down. Each card can show either a domain with unblock duration or \n        bonus re-roll. Bonus re-roll cards have a 10% chance to appear. \n        You start with {INITIAL_REROLLS} re-roll{INITIAL_REROLLS > 1 ? 's' : ''} and can earn more by selecting bonus re-roll cards. Then select one card.\n      </p>\n      \n      <div className=\"reroll-counter-container\">\n        {availableRerolls > 0 && !cardsLocked && (\n          <div className=\"reroll-counter\">\n            <span className=\"reroll-counter-label\">Re-roll{availableRerolls !== 1 ? 's' : ''} available:</span>\n            <span className=\"reroll-counter-value\">{availableRerolls}</span>\n          </div>\n        )}\n        {(timeRemaining > 0 && (cardsLocked || cards.length === 0)) && (\n          <div className=\"reroll-timer\">\n            Next selection in: <span className=\"timer-value\">{formatTimeRemaining(timeRemaining)}</span>\n          </div>\n        )}\n      </div>\n\n      <div className={`cards-wrapper ${(cardsLocked && selectedCard === null) || !isFocusTimeActive ? 'disabled' : ''} ${cards.length > 0 ? 'has-cards' : ''} ${selectedCard !== null ? 'card-selected' : ''}`}>\n        {cards.length === 0 && cardsLocked && !isFocusTimeActive && (\n          <div style={{ textAlign: 'center', padding: '40px', color: '#666', width: '100%' }}>\n            <p>No selection available</p>\n            <p>Start focus time to begin</p>\n          </div>\n        )}\n        {/* Only show \"No selection available\" when next selection timer is running (no card selected) */}\n        {cards.length === 0 && cardsLocked && isFocusTimeActive && timeRemaining > 0 && selectedCard === null && !selectedCardExpiresAt && (\n          <div style={{ textAlign: 'center', padding: '40px', color: '#666', width: '100%' }}>\n            <p>No selection available</p>\n            <p>Next selection in: <strong>{formatTimeRemaining(timeRemaining)}</strong></p>\n          </div>\n        )}\n        {cards.map((card, index) => (\n          <div key={`card-wrapper-${animationKey}-${index}`} className=\"card-wrapper\">\n            <div\n              key={`${animationKey}-${index}-${cardAnimationKeys[index] || 0}`}\n              className={`gamble-card ${showCards || cardAnimationKeys[index] > 0 ? 'card-drop' : ''} ${selectedCard === index && canceledCardIndex !== index ? 'card-clicked' : ''} ${canceledCardIndex === index || (selectedCard !== index && (cardsLocked || canceledCardIndex !== null || !isFocusTimeActive)) ? 'card-disabled' : ''} ${selectedCard === null && !cardsLocked && canceledCardIndex === null && isFocusTimeActive ? 'card-clickable' : ''}`}\n              style={{ animationDelay: `${index * 0.2}s` }}\n              onClick={() => selectedCard === null && !cardsLocked && canceledCardIndex === null && isFocusTimeActive && selectCard(index)}\n            >\n              {selectedCard === index && canceledCardIndex !== index && (\n                <div className=\"card-selected-banner\">\n                  SELECTED\n                </div>\n              )}\n              <div className=\"card-content\">\n                <div className=\"card-header\">\n                  <div className=\"card-domain\">\n                    {card.type === 'domain' && card.domain \n                      ? extractHostname(card.domain)\n                      : card.type === 'bonusRerolls'\n                      ? 'BONUS RE-ROLL'\n                      : ''}\n                  </div>\n                </div>\n                \n                <div className=\"card-symbol\">\n                  {card.type === 'domain' ? '‚è±Ô∏è' : 'üéÅ'}\n                </div>\n                \n                <div className=\"card-body\">\n                  {card.type === 'domain' && card.durationMinutes ? (\n                    <div className=\"card-duration\">\n                      {card.durationMinutes} {card.durationMinutes === 1 ? 'minute' : 'minutes'}\n                    </div>\n                  ) : card.type === 'bonusRerolls' && card.bonusRerolls ? (\n                    <div className=\"card-bonus-rerolls\">\n                      +1 re-roll\n                    </div>\n                  ) : null}\n                  \n                  {selectedCard === index && canceledCardIndex !== index && (\n                    <div className=\"card-selected-message\">\n                      {card.type === 'domain' && card.durationMinutes ? (\n                        <div className=\"card-selected-content\">\n                          <div className=\"card-selected-text\">\n                            ‚úì Selected! Unblocked for: <span className=\"card-countdown\">{formatUnblockCountdown(unblockTimeRemaining)}</span>\n                          </div>\n                          <button \n                            className=\"cancel-unblock-card-button\"\n                            onClick={(e) => {\n                              e.stopPropagation();\n                              handleCancelUnblock();\n                            }}\n                            title=\"Cancel this unblock\"\n                          >\n                            Cancel\n                          </button>\n                        </div>\n                      ) : card.type === 'bonusRerolls' && card.bonusRerolls ? (\n                        <>‚úì Bonus applied! You gained 1 re-roll!</>\n                      ) : null}\n                    </div>\n                  )}\n                  \n                  {selectedCard === null && (\n                    <div className=\"card-actions\">\n                      <div className=\"card-click-hint\">\n                        {cardsLocked \n                          ? 'Waiting for timer to reset...'\n                          : 'Click card to select'}\n                      </div>\n                    </div>\n                  )}\n                </div>\n              </div>\n            </div>\n            {selectedCard === null && (\n              <div className=\"card-reroll-section\">\n                <button\n                  onClick={() => rerollCard(index)}\n                  disabled={!canReroll}\n                  className=\"reroll-button\"\n                  title={!canReroll \n                    ? `No re-roll${availableRerolls !== 1 ? 's' : ''} left. Next selection in ${formatTimeRemaining(timeRemaining)}` \n                    : `${availableRerolls} re-roll${availableRerolls !== 1 ? 's' : ''} left`}\n                >\n                  <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\" strokeLinecap=\"round\" strokeLinejoin=\"round\">\n                    <path d=\"M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8\"></path>\n                    <path d=\"M21 3v5h-5\"></path>\n                    <path d=\"M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16\"></path>\n                    <path d=\"M3 21v-5h5\"></path>\n                  </svg>\n                </button>\n              </div>\n            )}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n\n","import React from \"react\";\nimport { Settings } from \"../types\";\n\ninterface BlockedSitesSectionProps {\n  settings: Settings;\n  onSave: (settings: Settings) => Promise<void>;\n}\n\n// Normalize domain for duplicate checking (case-insensitive, remove www)\nfunction normalizeDomainForCheck(domain: string): string {\n  return domain\n    .toLowerCase()\n    .replace(/^https?:\\/\\//i, '')\n    .replace(/\\/.*$/, '')\n    .replace(/^www\\./i, '')\n    .trim();\n}\n\nexport function BlockedSitesSection({ settings, onSave }: BlockedSitesSectionProps) {\n  const [host, setHost] = React.useState(\"\");\n\n  const addHost = async () => {\n    const h = host.trim().replace(/^https?:\\/\\//, \"\").replace(/\\/.*$/, \"\");\n    if (!h) return;\n    \n    // Normalize the input domain for comparison\n    const normalizedInput = normalizeDomainForCheck(h);\n    \n    // Check for duplicates using normalized comparison\n    const isDuplicate = settings.blockedHosts.some(existingHost => \n      normalizeDomainForCheck(existingHost) === normalizedInput\n    );\n    \n    if (isDuplicate) return;\n    \n    // Automatically add default durations (10, 15, 20, 25, 30 min) for new domains\n    const newDurations = { ...(settings.domainDurations || {}) };\n    if (!newDurations[h]) {\n      newDurations[h] = [];\n    }\n    // Add default durations if they don't already exist\n    const defaultDurations = [10, 15, 20, 25, 30];\n    defaultDurations.forEach(duration => {\n      if (!newDurations[h].includes(duration)) {\n        newDurations[h].push(duration);\n      }\n    });\n    // Sort durations for better UX\n    newDurations[h].sort((a, b) => a - b);\n    \n    await onSave({ \n      ...settings, \n      blockedHosts: [...settings.blockedHosts, h],\n      domainDurations: newDurations\n    });\n    setHost(\"\");\n  };\n\n  const removeHost = async (h: string) => {\n    const newDurations = { ...(settings.domainDurations || {}) };\n    delete newDurations[h];\n    await onSave({\n      ...settings,\n      blockedHosts: settings.blockedHosts.filter(x => x !== h),\n      domainDurations: newDurations\n    });\n  };\n\n  return (\n    <section>\n      <h2>Blocked sites</h2>\n      <div className=\"row\">\n        <input\n          placeholder=\"e.g. twitter.com\"\n          value={host}\n          onChange={e => setHost(e.target.value)}\n        />\n        <button onClick={addHost}>Add</button>\n      </div>\n      <ul className=\"host-list\">\n        {settings.blockedHosts.map(h => {\n          const durations = (settings.domainDurations || {})[h] || [];\n          return (\n            <li key={h} className=\"host-item\">\n              <div className=\"host-header\">\n                <span className=\"host-name\">{h}</span>\n                <button onClick={() => removeHost(h)}>remove</button>\n              </div>\n              <div className=\"durations-section\">\n                <label className=\"durations-label\">Unblock durations (minutes):</label>\n                <div className=\"durations-list\">\n                  {durations.map((dur, idx) => (\n                    <span key={idx} className=\"duration-tag\">\n                      {dur} min\n                      <button\n                        className=\"duration-remove\"\n                        onClick={async () => {\n                          const newDurations = { ...(settings.domainDurations || {}) };\n                          newDurations[h] = durations.filter((_, i) => i !== idx);\n                          if (newDurations[h].length === 0) {\n                            delete newDurations[h];\n                          }\n                          await onSave({ ...settings, domainDurations: newDurations });\n                        }}\n                      >\n                        √ó\n                      </button>\n                    </span>\n                  ))}\n                  <input\n                    type=\"number\"\n                    min=\"1\"\n                    placeholder=\"Add duration\"\n                    className=\"duration-input\"\n                    onKeyDown={async (e) => {\n                      if (e.key === 'Enter') {\n                        const input = e.currentTarget;\n                        const value = parseInt(input.value);\n                        if (value > 0) {\n                          const newDurations = { ...(settings.domainDurations || {}) };\n                          if (!newDurations[h]) {\n                            newDurations[h] = [];\n                          }\n                          // Check if duration already exists - don't add duplicates\n                          if (!newDurations[h].includes(value)) {\n                            newDurations[h] = [...newDurations[h], value];\n                            // Sort durations for better UX\n                            newDurations[h].sort((a, b) => a - b);\n                            await onSave({ ...settings, domainDurations: newDurations });\n                          }\n                          input.value = '';\n                        }\n                      }\n                    }}\n                  />\n                </div>\n              </div>\n            </li>\n          );\n        })}\n      </ul>\n    </section>\n  );\n}\n\n","import React from \"react\";\nimport { Settings, BlockWindow } from \"../types\";\n\nconst DAYS = [\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\"];\n\ninterface TimeWindowsSectionProps {\n  settings: Settings;\n  onSave: (settings: Settings) => Promise<void>;\n}\n\nexport function TimeWindowsSection({ settings, onSave }: TimeWindowsSectionProps) {\n  const mode = settings.mode || 'scheduled';\n  const isDisabled = mode === 'focus';\n\n  const addWindow = async () => {\n    const w: BlockWindow = { day: 1, start: \"09:00\", end: \"17:00\" };\n    await onSave({ ...settings, windows: [...settings.windows, w] });\n  };\n\n  const updateWindow = async (idx: number, patch: Partial<BlockWindow>) => {\n    const windows = settings.windows.slice();\n    windows[idx] = { ...windows[idx], ...patch };\n    await onSave({ ...settings, windows });\n  };\n\n  const removeWindow = async (idx: number) => {\n    const windows = settings.windows.slice();\n    windows.splice(idx, 1);\n    await onSave({ ...settings, windows });\n  };\n\n  return (\n    <section>\n      <h2>Time windows</h2>\n      {isDisabled && (\n        <div style={{ padding: '12px', backgroundColor: '#f0f0f0', borderRadius: '8px', color: '#666', marginBottom: '12px' }}>\n          Time windows are disabled. Focus timer is active.\n        </div>\n      )}\n      <button onClick={addWindow} disabled={isDisabled}>Add window</button>\n      {settings.windows.map((w, i) => (\n        <div key={i} className=\"card\">\n          <label>\n            Day:\n            <select value={w.day} onChange={e => updateWindow(i, { day: Number(e.target.value) })} disabled={isDisabled}>\n              {DAYS.map((d, idx) => (\n                <option value={idx} key={idx}>{d}</option>\n              ))}\n            </select>\n          </label>\n          <label>\n            Start:\n            <input type=\"time\" value={w.start} onChange={e => updateWindow(i, { start: e.target.value })} disabled={isDisabled} />\n          </label>\n          <label>\n            End:\n            <input type=\"time\" value={w.end} onChange={e => updateWindow(i, { end: e.target.value })} disabled={isDisabled} />\n          </label>\n          <button onClick={() => removeWindow(i)} disabled={isDisabled}>remove</button>\n        </div>\n      ))}\n    </section>\n  );\n}\n\n","import React from \"react\";\nimport { Settings } from \"../types\";\n\ninterface MasterSwitchSectionProps {\n  settings: Settings;\n  onSave: (settings: Settings) => Promise<void>;\n}\n\nexport function MasterSwitchSection({ settings, onSave }: MasterSwitchSectionProps) {\n  return (\n    <section>\n      <h2>Master switch</h2>\n      <label>\n        <input\n          type=\"checkbox\"\n          checked={settings.enabled}\n          onChange={e => onSave({ ...settings, enabled: e.target.checked })}\n        />\n        Enabled\n      </label>\n    </section>\n  );\n}\n\n","import React from \"react\";\nimport { DEFAULT_SETTINGS } from \"../types\";\nimport { storage } from \"../lib/browser-api\";\n\ninterface ResetSectionProps {\n  onReset: () => Promise<void>;\n}\n\nexport function ResetSection({ onReset }: ResetSectionProps) {\n  const resetToDefaults = async () => {\n    if (confirm('Reset all settings to defaults? This cannot be undone.')) {\n      await storage.sync.remove(\"settings\");\n      await onReset();\n    }\n  };\n\n  return (\n    <section>\n      <h2>Reset</h2>\n      <button onClick={resetToDefaults} className=\"reset-button\">\n        Reset to Defaults\n      </button>\n      <p className=\"reset-description\">\n        This will clear all saved settings and restore defaults.\n      </p>\n    </section>\n  );\n}\n\n","import React from \"react\";\nimport { Settings } from \"../types\";\n\ninterface FocusTimerSectionProps {\n  settings: Settings;\n  onSave: (settings: Settings) => Promise<void>;\n}\n\nexport function FocusTimerSection({ settings, onSave }: FocusTimerSectionProps) {\n  const [hours, setHours] = React.useState(settings.focusTimeHours || 2);\n  const [timeRemaining, setTimeRemaining] = React.useState<number | null>(null);\n  const isPausedRef = React.useRef(false);\n\n  const mode = settings.mode || 'scheduled';\n\n  // Update hours when settings change\n  React.useEffect(() => {\n    if (settings.focusTimeHours) {\n      setHours(settings.focusTimeHours);\n    }\n  }, [settings.focusTimeHours]);\n\n  // Calculate time remaining if focus time is active\n  React.useEffect(() => {\n    let interval: number | null = null;\n    \n    if (mode === 'focus') {\n      // Update ref to track paused state\n      isPausedRef.current = !!(settings.focusTimePaused && settings.focusTimePaused > 0);\n      \n      // Check paused state first - if paused, show static time and don't start interval\n      if (settings.focusTimePaused && settings.focusTimePaused > 0) {\n        setTimeRemaining(settings.focusTimePaused);\n        // No interval when paused - timer is frozen\n        return () => {\n          if (interval) clearInterval(interval);\n        };\n      } \n      // If not paused and has end time, start countdown\n      else if (settings.focusTimeEnd && !settings.focusTimePaused) {\n        const updateTimer = () => {\n          // Check ref to see if we're paused (handles async updates)\n          if (isPausedRef.current) {\n            if (interval) clearInterval(interval);\n            return;\n          }\n          \n          const now = Date.now();\n          const remaining = Math.max(0, settings.focusTimeEnd! - now);\n          setTimeRemaining(remaining);\n          \n          if (remaining === 0) {\n            // Focus time ended, switch back to scheduled mode\n            onSave({ ...settings, mode: 'scheduled', focusTimeEnd: undefined });\n          }\n        };\n\n        updateTimer();\n        interval = setInterval(updateTimer, 1000);\n        return () => {\n          if (interval) clearInterval(interval);\n        };\n      } else {\n        setTimeRemaining(null);\n      }\n    } else {\n      isPausedRef.current = false;\n      setTimeRemaining(null);\n    }\n    \n    return () => {\n      if (interval) clearInterval(interval);\n    };\n  }, [mode, settings.focusTimeEnd, settings.focusTimePaused, settings, onSave]);\n\n  const startFocusTime = async () => {\n    const now = Date.now();\n    const hoursInMs = hours * 60 * 60 * 1000;\n    const endTime = now + hoursInMs;\n    \n    await onSave({\n      ...settings,\n      mode: 'focus',\n      focusTimeHours: hours,\n      focusTimeEnd: endTime\n    });\n  };\n\n  const stopFocusTime = async () => {\n    await onSave({\n      ...settings,\n      mode: 'scheduled',\n      focusTimeEnd: undefined\n    });\n  };\n\n  const formatTime = (ms: number): string => {\n    const totalSeconds = Math.floor(ms / 1000);\n    const hours = Math.floor(totalSeconds / 3600);\n    const minutes = Math.floor((totalSeconds % 3600) / 60);\n    const seconds = totalSeconds % 60;\n    \n    if (hours > 0) {\n      return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;\n    }\n    return `${minutes}:${seconds.toString().padStart(2, '0')}`;\n  };\n\n  const isFocusTimeActive = mode === 'focus' && (settings.focusTimeEnd || settings.focusTimePaused) && timeRemaining !== null && timeRemaining > 0;\n  const isPaused = mode === 'focus' && settings.focusTimePaused && !settings.focusTimeEnd;\n\n  return (\n    <section>\n      <h2>Focus Timer</h2>\n      \n      <div style={{ marginBottom: '16px' }}>\n        <label style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '12px' }}>\n          <input\n            type=\"radio\"\n            name=\"mode\"\n            checked={mode === 'focus'}\n            onChange={() => onSave({ ...settings, mode: 'focus' })}\n          />\n          <span>Use Focus Timer</span>\n        </label>\n        <label style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>\n          <input\n            type=\"radio\"\n            name=\"mode\"\n            checked={mode === 'scheduled'}\n            onChange={() => onSave({ ...settings, mode: 'scheduled', focusTimeEnd: undefined })}\n          />\n          <span>Use Scheduled Working Hours</span>\n        </label>\n      </div>\n\n      {mode === 'focus' && (\n        <div className=\"card\" style={{ gridTemplateColumns: '1fr', padding: '16px' }}>\n          {!isFocusTimeActive ? (\n            <>\n              <label>\n                Hours to focus:\n                <input\n                  type=\"number\"\n                  min=\"0.5\"\n                  max=\"24\"\n                  step=\"0.5\"\n                  value={hours}\n                  onChange={(e) => setHours(parseFloat(e.target.value) || 2)}\n                  style={{ width: '100px', marginLeft: '8px' }}\n                />\n              </label>\n              <button onClick={startFocusTime} style={{ marginTop: '8px' }}>\n                Start Focus Time\n              </button>\n            </>\n          ) : (\n            <>\n              <div style={{ fontSize: '24px', fontWeight: 'bold', textAlign: 'center', marginBottom: '12px' }}>\n                {formatTime(timeRemaining!)}\n              </div>\n              <div style={{ textAlign: 'center', color: '#666', marginBottom: '12px' }}>\n                {isPaused ? (\n                  <>Focus time paused - card timer is active</>\n                ) : (\n                  <>Focus time active - blocked sites are being blocked</>\n                )}\n              </div>\n              {!isPaused && (\n                <button onClick={stopFocusTime} style={{ backgroundColor: '#ff4444', color: 'white' }}>\n                  Stop Focus Time\n                </button>\n              )}\n            </>\n          )}\n        </div>\n      )}\n\n      {mode === 'scheduled' && (\n        <div style={{ padding: '12px', backgroundColor: '#f0f0f0', borderRadius: '8px', color: '#666' }}>\n          Focus timer is disabled. Using scheduled working hours instead.\n        </div>\n      )}\n    </section>\n  );\n}\n\n","import React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport \"../styles/common.css\";\nimport \"../styles/Options.css\";\nimport { DEFAULT_SETTINGS, Settings } from \"../types\";\nimport { CardGamble } from \"../components/CardGamble\";\nimport { BlockedSitesSection } from \"../components/BlockedSitesSection\";\nimport { TimeWindowsSection } from \"../components/TimeWindowsSection\";\nimport { MasterSwitchSection } from \"../components/MasterSwitchSection\";\nimport { ResetSection } from \"../components/ResetSection\";\nimport { FocusTimerSection } from \"../components/FocusTimerSection\";\nimport { storage, runtime } from \"../lib/browser-api\";\n\nconst STORAGE_KEY = \"settings\";\n\nfunction Options() {\n  const [settings, setSettings] = React.useState<Settings>(DEFAULT_SETTINGS);\n  const [cardGambleResetKey, setCardGambleResetKey] = React.useState(0);\n\n  React.useEffect(() => {\n    const loadSettings = async () => {\n      const { [STORAGE_KEY]: s } = await storage.sync.get(STORAGE_KEY);\n      setSettings({ ...DEFAULT_SETTINGS, ...(s || {}) });\n    };\n    \n    loadSettings();\n    \n    // Listen for storage changes (e.g., when CardGamble pauses focus timer)\n    if (storage.onChanged) {\n      const listener = (changes: any, area: string) => {\n        if (area === \"sync\" && changes[STORAGE_KEY]) {\n          const newSettings = changes[STORAGE_KEY].newValue;\n          if (newSettings) {\n            setSettings({ ...DEFAULT_SETTINGS, ...newSettings });\n          }\n        }\n      };\n      \n      storage.onChanged.addListener(listener);\n      return () => {\n        if (storage.onChanged && 'removeListener' in storage.onChanged) {\n          (storage.onChanged as any).removeListener(listener);\n        }\n      };\n    }\n  }, []);\n\n  const save = async (next: Settings) => {\n    setSettings(next);\n    await storage.sync.set({ [STORAGE_KEY]: next });\n  };\n\n  const resetToDefaults = async () => {\n    setSettings(DEFAULT_SETTINGS);\n    // Trigger CardGamble reset by incrementing the key\n    setCardGambleResetKey(prev => prev + 1);\n    // Clear all temporary unblocks\n    try {\n      await runtime.sendMessage({ action: 'clearTemporaryUnblocks' });\n    } catch (error) {\n      console.error('Error clearing temporary unblocks:', error);\n    }\n  };\n\n  return (\n    <div className=\"p\">\n      <FocusTimerSection settings={settings} onSave={save} />\n      <h1>Blocker Options</h1>\n\n      {settings.blockedHosts.length > 0 && (\n        <section>\n          <CardGamble \n            domains={settings.blockedHosts} \n            domainDurations={settings.domainDurations || {}}\n            resetKey={cardGambleResetKey}\n          />\n        </section>\n      )}\n\n      <BlockedSitesSection settings={settings} onSave={save} />\n\n      <TimeWindowsSection settings={settings} onSave={save} />\n\n      <MasterSwitchSection settings={settings} onSave={save} />\n\n      <ResetSection onReset={resetToDefaults} />\n    </div>\n  );\n}\n\nReactDOM.createRoot(document.getElementById(\"root\")!).render(<Options />);\n"],"names":["extractHostname","domain","hostname","generateRandomOption","domains","domainDurations","randomIndex","randomDomain","customDurations","unblockMinutes","durationIndex","REROLL_STATE_KEY","MIN_REROLL_RESET_MINUTES","MAX_REROLL_RESET_MINUTES","INITIAL_REROLLS","generateRandomResetTime","minutes","CardGamble","resetKey","cards","setCards","React","showCards","setShowCards","selectedCard","setSelectedCard","animationKey","setAnimationKey","availableRerolls","setAvailableRerolls","rerollResetTime","setRerollResetTime","rerollResetTimePaused","setRerollResetTimePaused","timeRemaining","setTimeRemaining","isLoadingState","setIsLoadingState","cardsLocked","setCardsLocked","selectedCardExpiresAt","setSelectedCardExpiresAt","unblockTimeRemaining","setUnblockTimeRemaining","canceledCardIndex","setCanceledCardIndex","cardAnimationKeys","setCardAnimationKeys","isFocusTimeActive","setIsFocusTimeActive","settings","storage","isActive","error","listener","changes","area","newSettings","state","rerollState","now","selectedCardData","response","runtime","normalizedDomain","matchingUnblock","u","initialResetTime","newCards","prev","updateTimer","remaining","interval","rerollCard","cardIndex","newKeys","prevCards","selectCard","card","expiresAt","updateCountdown","resumeFocusTimer","resumeRerollTimer","formatTimeRemaining","ms","totalSeconds","seconds","formatUnblockCountdown","hours","newEndTime","newResetTime","handleCancelUnblock","canReroll","jsxs","jsx","index","e","Fragment","normalizeDomainForCheck","BlockedSitesSection","onSave","host","setHost","addHost","h","normalizedInput","existingHost","newDurations","duration","a","b","removeHost","x","durations","dur","idx","_","i","input","value","DAYS","TimeWindowsSection","isDisabled","addWindow","w","updateWindow","patch","windows","removeWindow","d","MasterSwitchSection","ResetSection","onReset","resetToDefaults","FocusTimerSection","setHours","isPausedRef","mode","startFocusTime","hoursInMs","endTime","stopFocusTime","formatTime","isPaused","STORAGE_KEY","Options","setSettings","DEFAULT_SETTINGS","cardGambleResetKey","setCardGambleResetKey","s","save","next","ReactDOM"],"mappings":"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"}