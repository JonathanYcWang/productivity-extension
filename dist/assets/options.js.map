{"version":3,"file":"options.js","sources":["../../src/components/CardGamble.tsx","../../src/components/BlockedSitesSection.tsx","../../src/components/TimeWindowsSection.tsx","../../src/components/MasterSwitchSection.tsx","../../src/components/ResetSection.tsx","../../src/options/App.tsx"],"sourcesContent":["import React from \"react\";\nimport \"../styles/CardGamble.css\";\nimport { TemporaryUnblock } from \"../types\";\nimport { storage, runtime } from \"../lib/browser-api\";\n\ninterface CardGambleProps {\n  domains: string[];\n  domainDurations?: Record<string, number[]>; // durations in minutes for each domain\n  resetKey?: number; // When this changes, reset all state\n}\n\ninterface CardOption {\n  type: 'domain' | 'bonusRerolls';\n  domain?: string;\n  durationMinutes?: number;\n  bonusRerolls?: number; // 1, 2, or 3\n}\n\n// Extract just the hostname from a domain string\nfunction extractHostname(domain: string): string {\n  try {\n    // Remove protocol if present\n    let hostname = domain.replace(/^https?:\\/\\//i, '');\n    // Remove path, query strings, and fragments\n    hostname = hostname.split('/')[0].split('?')[0].split('#')[0];\n    // Remove port if present\n    hostname = hostname.split(':')[0];\n    // Remove www. prefix\n    hostname = hostname.replace(/^www\\./i, '');\n    // Trim whitespace\n    hostname = hostname.trim();\n    return hostname;\n  } catch {\n    // If parsing fails, just clean up the string\n    return domain\n      .replace(/^https?:\\/\\//i, '')\n      .replace(/\\/.*$/, '')\n      .replace(/\\?.*$/, '')\n      .replace(/#.*$/, '')\n      .replace(/:.*$/, '')\n      .replace(/^www\\./i, '')\n      .trim();\n  }\n}\n\n// Generate a random option - domain or bonus reroll card\n// Bonus rerolls have 10% chance, domains have 90% chance (distributed equally)\nfunction generateRandomOption(\n  domains: string[],\n  domainDurations: Record<string, number[]>\n): CardOption {\n  if (domains.length === 0) {\n    // If no domains, return bonus reroll\n    return { type: 'bonusRerolls', bonusRerolls: 1 };\n  }\n\n  // 10% chance for bonus reroll, 90% chance for domain\n  const random = Math.random();\n  if (random < 0.1) {\n    // Generate a bonus reroll card (always 1 reroll)\n    return {\n      type: 'bonusRerolls',\n      bonusRerolls: 1\n    };\n  } else {\n    // Generate a domain card (90% chance, distributed equally among domains)\n    const randomIndex = Math.floor(Math.random() * domains.length);\n    const randomDomain = domains[randomIndex];\n    const customDurations = domainDurations[randomDomain] || [];\n    \n    let unblockMinutes: number;\n    if (customDurations.length > 0) {\n      const durationIndex = Math.floor(Math.random() * customDurations.length);\n      unblockMinutes = customDurations[durationIndex];\n    } else {\n      // Default: random duration between 5 minutes and 2 hours\n      const minMinutes = 5;\n      const maxMinutes = 120;\n      unblockMinutes = Math.floor(Math.random() * (maxMinutes - minMinutes + 1)) + minMinutes;\n    }\n\n    return {\n      type: 'domain',\n      domain: randomDomain,\n      durationMinutes: unblockMinutes\n    };\n  }\n}\n\nconst REROLL_STATE_KEY = \"cardGambleRerollState\";\n\ninterface RerollState {\n  availableRerolls: number; // Track available rerolls directly (can exceed initial)\n  rerollResetTime: number | null;\n  lastCardGeneration: number; // timestamp when cards were last generated\n  cards: CardOption[]; // Current cards displayed\n  selectedCard: number | null; // Which card is selected\n  cardsLocked: boolean; // Whether cards are locked\n  showCards: boolean; // Whether cards are showing\n  animationKey: number; // Animation key for card animations\n  selectedCardExpiresAt: number | null; // When the selected domain card expires\n}\n\nconst DEFAULT_REROLL_RESET_MINUTES = 60;\nconst INITIAL_REROLLS = 5; // Starting number of rerolls\n\nexport function CardGamble({ domains, domainDurations = {}, resetKey }: CardGambleProps) {\n  const [cards, setCards] = React.useState<CardOption[]>([]);\n  const [showCards, setShowCards] = React.useState(false);\n  const [selectedCard, setSelectedCard] = React.useState<number | null>(null);\n  const [animationKey, setAnimationKey] = React.useState(0);\n  const [availableRerolls, setAvailableRerolls] = React.useState(INITIAL_REROLLS);\n  const [rerollResetTime, setRerollResetTime] = React.useState<number | null>(null);\n  const [timeRemaining, setTimeRemaining] = React.useState<number>(0);\n  const [isLoadingState, setIsLoadingState] = React.useState(true);\n  const [cardsLocked, setCardsLocked] = React.useState(false);\n  const [selectedCardExpiresAt, setSelectedCardExpiresAt] = React.useState<number | null>(null);\n  const [unblockTimeRemaining, setUnblockTimeRemaining] = React.useState<number>(0);\n  const [canceledCardIndex, setCanceledCardIndex] = React.useState<number | null>(null);\n  const [cardAnimationKeys, setCardAnimationKeys] = React.useState<number[]>([0, 0, 0]); // Per-card animation keys\n\n  // Load persisted reroll state\n  React.useEffect(() => {\n    const loadRerollState = async () => {\n      try {\n        const { [REROLL_STATE_KEY]: state } = await storage.local.get(REROLL_STATE_KEY);\n        if (state) {\n          const rerollState: RerollState = state;\n          const now = Date.now();\n          \n          // Check if timer has expired\n          if (rerollState.rerollResetTime && rerollState.rerollResetTime <= now) {\n            // Timer expired, reset rerolls\n            setAvailableRerolls(INITIAL_REROLLS);\n            setRerollResetTime(null);\n            setCardsLocked(false); // Unlock cards\n            setSelectedCard(null); // Clear selection\n            await storage.local.remove(REROLL_STATE_KEY);\n            // Cards will be regenerated by the initialization effect\n          } else {\n            // Load persisted state\n            setAvailableRerolls(rerollState.availableRerolls ?? INITIAL_REROLLS);\n            setRerollResetTime(rerollState.rerollResetTime);\n            \n            // Load card state if it exists\n            if (rerollState.cards && rerollState.cards.length > 0) {\n              setCards(rerollState.cards);\n              setSelectedCard(rerollState.selectedCard ?? null);\n              setCardsLocked(rerollState.cardsLocked ?? false);\n              setShowCards(rerollState.showCards ?? true);\n              setAnimationKey(rerollState.animationKey ?? 0);\n              \n              // Try to restore expiration time from persisted state or active unblocks\n              if (rerollState.selectedCardExpiresAt) {\n                setSelectedCardExpiresAt(rerollState.selectedCardExpiresAt);\n              } else if (rerollState.selectedCard !== null && rerollState.selectedCard !== undefined) {\n                // If we have a selected card but no expiration time, try to get it from active unblocks\n                const selectedCardData = rerollState.cards[rerollState.selectedCard];\n                if (selectedCardData && selectedCardData.type === 'domain' && selectedCardData.domain) {\n                  try {\n                    const response = await runtime.sendMessage({ action: 'getActiveUnblocks' });\n                    if (response && response.success && response.unblocks) {\n                      const normalizedDomain = extractHostname(selectedCardData.domain).toLowerCase();\n                      const matchingUnblock = response.unblocks.find((u: TemporaryUnblock) => \n                        extractHostname(u.domain).toLowerCase() === normalizedDomain\n                      );\n                      if (matchingUnblock) {\n                        setSelectedCardExpiresAt(matchingUnblock.expiresAt);\n                      }\n                    }\n                  } catch (error) {\n                    console.error('Error fetching active unblocks on load:', error);\n                  }\n                }\n              }\n            }\n            \n            // If timer is running, cards should be locked\n            // (a card was selected and we're waiting for timer to reset)\n            if (rerollState.rerollResetTime && rerollState.rerollResetTime > now) {\n              setCardsLocked(true);\n            }\n            \n            // If timer is still active, notify background script\n            if (rerollState.rerollResetTime && rerollState.rerollResetTime > now) {\n              try {\n                runtime.sendMessage({\n                  action: 'scheduleRerollReset',\n                  resetTime: rerollState.rerollResetTime\n                });\n              } catch (error) {\n                console.error('Error scheduling reroll reset:', error);\n              }\n            }\n          }\n        }\n      } catch (error) {\n        console.error('Error loading reroll state:', error);\n      } finally {\n        setIsLoadingState(false);\n      }\n    };\n    \n    loadRerollState();\n  }, []);\n\n  // Save reroll state whenever it changes\n  React.useEffect(() => {\n    if (isLoadingState) return; // Don't save during initial load\n    \n    const saveRerollState = async () => {\n      try {\n        const state: RerollState = {\n          availableRerolls,\n          rerollResetTime,\n          lastCardGeneration: Date.now(),\n          cards,\n          selectedCard,\n          cardsLocked,\n          showCards,\n          animationKey,\n          selectedCardExpiresAt\n        };\n        await storage.local.set({ [REROLL_STATE_KEY]: state });\n      } catch (error) {\n        console.error('Error saving reroll state:', error);\n      }\n    };\n    \n    saveRerollState();\n  }, [availableRerolls, rerollResetTime, cards, selectedCard, cardsLocked, showCards, animationKey, selectedCardExpiresAt, isLoadingState]);\n\n  // Reset all state when resetKey changes\n  React.useEffect(() => {\n    if (resetKey === undefined) return; // Don't reset on initial mount\n    \n    const resetAll = async () => {\n      // Reset all state\n      setAvailableRerolls(INITIAL_REROLLS);\n      setRerollResetTime(null);\n      setCardsLocked(false);\n      setSelectedCard(null);\n      setTimeRemaining(0);\n      setSelectedCardExpiresAt(null);\n      setCanceledCardIndex(null);\n      \n      // Clear persisted state\n      await chrome.storage.local.remove(REROLL_STATE_KEY);\n      \n      // Cancel any scheduled alarms\n      try {\n        chrome.runtime.sendMessage({\n          action: 'cancelRerollReset'\n        });\n      } catch (error) {\n        console.error('Error canceling reroll reset:', error);\n      }\n      \n      // Regenerate cards\n      if (domains.length > 0) {\n        const newCards = Array.from({ length: 3 }, () => \n          generateRandomOption(domains, domainDurations)\n        );\n        setCards(newCards);\n        setCardAnimationKeys([0, 0, 0]); // Reset per-card animation keys\n        setAnimationKey(prev => prev + 1);\n        setShowCards(false);\n        setTimeout(() => {\n          setShowCards(true);\n        }, 50);\n      }\n    };\n    \n    resetAll();\n  }, [resetKey]); // Only reset when resetKey changes, not when domains change\n\n  // Initialize cards when component mounts or domains change (only if no persisted cards exist)\n  React.useEffect(() => {\n    if (domains.length > 0 && !isLoadingState && cards.length === 0) {\n      const initialCards = Array.from({ length: 3 }, () => \n        generateRandomOption(domains, domainDurations)\n      );\n      setCards(initialCards);\n      setCardAnimationKeys([0, 0, 0]); // Initialize per-card animation keys\n      setSelectedCard(null);\n      // Cards lock state is managed separately - don't change it here\n      // Cards will be locked if a card was selected and timer is running\n      setShowCards(false);\n      // Trigger animation by resetting key and showing cards\n      setAnimationKey(prev => prev + 1);\n      // Small delay to ensure DOM is ready for animation\n      setTimeout(() => {\n        setShowCards(true);\n      }, 50);\n    }\n  }, [domains, domainDurations, isLoadingState, cards.length]);\n\n  // Timer countdown effect\n  React.useEffect(() => {\n    if (!rerollResetTime) {\n      setTimeRemaining(0);\n      return;\n    }\n\n    const updateTimer = () => {\n      const now = Date.now();\n      const remaining = Math.max(0, rerollResetTime - now);\n      setTimeRemaining(remaining);\n\n      if (remaining === 0) {\n        // Reset re-rolls when timer expires\n        setAvailableRerolls(INITIAL_REROLLS);\n        setRerollResetTime(null);\n        setCardsLocked(false); // Unlock cards when timer resets\n        setSelectedCard(null); // Clear selection - reset all cards\n        setSelectedCardExpiresAt(null);\n        setCanceledCardIndex(null);\n        // Regenerate cards for new round\n        if (domains.length > 0) {\n          const newCards = Array.from({ length: 3 }, () => \n            generateRandomOption(domains, domainDurations)\n          );\n          setCards(newCards);\n          setAnimationKey(prev => prev + 1);\n          setShowCards(false);\n          setTimeout(() => {\n            setShowCards(true);\n          }, 50);\n        }\n        // Clear persisted state\n        storage.local.remove(REROLL_STATE_KEY).catch(console.error);\n      }\n    };\n\n    updateTimer();\n    const interval = setInterval(updateTimer, 1000);\n\n    return () => clearInterval(interval);\n  }, [rerollResetTime, availableRerolls, domains, domainDurations]);\n\n  const rerollCard = (cardIndex: number) => {\n    // Check if user has any available rerolls\n    if (availableRerolls <= 0) return;\n\n    // Trigger animation by incrementing the animation key for this specific card\n    setCardAnimationKeys(prev => {\n      const newKeys = [...prev];\n      newKeys[cardIndex] = (newKeys[cardIndex] || 0) + 1;\n      return newKeys;\n    });\n\n    // Small delay to allow animation to start, then update the card\n    setTimeout(() => {\n      setCards(prevCards => {\n        const newCards = [...prevCards];\n        newCards[cardIndex] = generateRandomOption(domains, domainDurations);\n        return newCards;\n      });\n    }, 50);\n\n    setAvailableRerolls(prev => prev - 1);\n    // Timer is started when a card is selected, not when rerolls are used\n  };\n\n  const selectCard = async (cardIndex: number) => {\n    if (selectedCard !== null || cardsLocked) return; // Already selected or cards are locked\n    \n    const card = cards[cardIndex];\n    if (!card) return;\n\n    if (card.type === 'bonusRerolls' && card.bonusRerolls) {\n      // Bonus reroll card - add rerolls to the pool and replace this card\n      setAvailableRerolls(prev => prev + card.bonusRerolls!);\n      \n      // Replace only this card with a new random card, keep others unchanged\n      setCards(prevCards => {\n        const newCards = [...prevCards];\n        newCards[cardIndex] = generateRandomOption(domains, domainDurations);\n        return newCards;\n      });\n      \n      // Don't lock cards or start timer for bonus reroll cards\n      return;\n    }\n    \n    // For domain cards, lock cards, reset rerolls, and start timer\n    setSelectedCard(cardIndex);\n    setCardsLocked(true); // Lock all cards after selection\n    setAvailableRerolls(0); // Lose all rerolls when a domain card is selected\n    \n    // Start timer when a domain card is selected (full duration)\n    if (!rerollResetTime) {\n      const resetTime = Date.now() + DEFAULT_REROLL_RESET_MINUTES * 60 * 1000;\n      setRerollResetTime(resetTime);\n      \n      // Notify background script to schedule the alarm\n      try {\n        chrome.runtime.sendMessage({\n          action: 'scheduleRerollReset',\n          resetTime: resetTime\n        });\n      } catch (error) {\n        console.error('Error scheduling reroll reset:', error);\n      }\n    }\n    \n    if (card.type === 'domain' && card.domain && card.durationMinutes) {\n      // Domain card - unblock the domain\n      const expiresAt = Date.now() + (card.durationMinutes * 60 * 1000);\n      setSelectedCardExpiresAt(expiresAt);\n      \n      // Send message to background script to temporarily unblock this domain\n      try {\n        await runtime.sendMessage({\n          action: 'temporaryUnblock',\n          domain: card.domain,\n          expiresAt: expiresAt,\n          durationMinutes: card.durationMinutes\n        });\n        \n        // Timer and cards remain locked until timer resets - don't clear selectedCard or cardsLocked\n      } catch (error) {\n        console.error('Error sending unblock message:', error);\n      }\n    }\n  };\n\n  // Update unblock countdown for selected card\n  React.useEffect(() => {\n    if (!selectedCardExpiresAt) {\n      setUnblockTimeRemaining(0);\n      return;\n    }\n\n    const updateCountdown = () => {\n      const now = Date.now();\n      const remaining = Math.max(0, selectedCardExpiresAt - now);\n      setUnblockTimeRemaining(remaining);\n      \n      // If expired, automatically disable the card\n      if (remaining === 0 && selectedCard !== null) {\n        const canceledIndex = selectedCard;\n        setCanceledCardIndex(canceledIndex);\n        setSelectedCard(null);\n        setSelectedCardExpiresAt(null);\n        setCardsLocked(false); // Unlock cards so user can select again\n      }\n    };\n\n    updateCountdown();\n    const interval = setInterval(updateCountdown, 1000);\n    return () => clearInterval(interval);\n  }, [selectedCardExpiresAt, selectedCard]);\n\n  // Format time remaining as MM:SS\n  const formatTimeRemaining = (ms: number): string => {\n    if (ms <= 0) return '00:00';\n    const totalSeconds = Math.floor(ms / 1000);\n    const minutes = Math.floor(totalSeconds / 60);\n    const seconds = totalSeconds % 60;\n    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;\n  };\n\n  // Format unblock time remaining in a readable format\n  const formatUnblockCountdown = (ms: number): string => {\n    if (ms <= 0) return 'Expired';\n    \n    const totalSeconds = Math.floor(ms / 1000);\n    const hours = Math.floor(totalSeconds / 3600);\n    const minutes = Math.floor((totalSeconds % 3600) / 60);\n    const seconds = totalSeconds % 60;\n    \n    if (hours > 0) {\n      return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;\n    }\n    return `${minutes}:${seconds.toString().padStart(2, '0')}`;\n  };\n\n  // Handle canceling the selected card's unblock\n  const handleCancelUnblock = async () => {\n    if (selectedCard === null) return;\n    \n    const card = cards[selectedCard];\n    if (!card || card.type !== 'domain' || !card.domain) return;\n\n    try {\n      // Cancel the temporary unblock\n      await runtime.sendMessage({ \n        action: 'cancelTemporaryUnblock', \n        domain: card.domain \n      });\n      \n      // Set timer to zero immediately\n      setUnblockTimeRemaining(0);\n      \n      // Change card from selected to disabled state\n      const canceledIndex = selectedCard;\n      setCanceledCardIndex(canceledIndex);\n      setSelectedCard(null);\n      setSelectedCardExpiresAt(null);\n      // Keep cards locked so all cards remain disabled (like when a card is selected)\n    } catch (error) {\n      console.error('Error canceling unblock:', error);\n    }\n  };\n\n\n  if (domains.length === 0) return null;\n\n  const canReroll = availableRerolls > 0;\n\n  return (\n    <div className=\"card-gamble-container\">\n      <h2>Gamble for Unblock Time</h2>\n      <p className=\"card-gamble-description\">\n        Three cards will drop down. Each card can show either a domain with unblock duration or \n        bonus re-roll. Bonus re-roll cards have a 10% chance to appear. \n        You start with {INITIAL_REROLLS} re-roll{INITIAL_REROLLS > 1 ? 's' : ''} and can earn more by selecting bonus re-roll cards. Then select one card.\n      </p>\n      \n      <div className=\"reroll-counter-container\">\n        {availableRerolls > 0 && (\n          <div className=\"reroll-counter\">\n            <span className=\"reroll-counter-label\">Re-roll{availableRerolls !== 1 ? 's' : ''} available:</span>\n            <span className=\"reroll-counter-value\">{availableRerolls}</span>\n          </div>\n        )}\n        {availableRerolls === 0 && timeRemaining > 0 && (\n          <div className=\"reroll-timer\">\n            Next selection in: <span className=\"timer-value\">{formatTimeRemaining(timeRemaining)}</span>\n          </div>\n        )}\n      </div>\n\n      <div className=\"cards-wrapper\">\n        {cards.map((card, index) => (\n          <div key={`card-wrapper-${animationKey}-${index}`} className=\"card-wrapper\">\n            <div\n              key={`${animationKey}-${index}-${cardAnimationKeys[index] || 0}`}\n              className={`gamble-card ${showCards || cardAnimationKeys[index] > 0 ? 'card-drop' : ''} ${selectedCard === index && canceledCardIndex !== index ? 'card-clicked' : ''} ${canceledCardIndex === index || (selectedCard !== index && (cardsLocked || canceledCardIndex !== null)) ? 'card-disabled' : ''} ${selectedCard === null && !cardsLocked && canceledCardIndex === null ? 'card-clickable' : ''}`}\n              style={{ animationDelay: `${index * 0.2}s` }}\n              onClick={() => selectedCard === null && !cardsLocked && canceledCardIndex === null && selectCard(index)}\n            >\n              {selectedCard === index && canceledCardIndex !== index && (\n                <div className=\"card-selected-banner\">\n                  SELECTED\n                </div>\n              )}\n              <div className=\"card-content\">\n                <div className=\"card-header\">\n                  <div className=\"card-domain\">\n                    {card.type === 'domain' && card.domain \n                      ? extractHostname(card.domain)\n                      : card.type === 'bonusRerolls'\n                      ? 'BONUS RE-ROLL'\n                      : ''}\n                  </div>\n                </div>\n                \n                <div className=\"card-symbol\">\n                  {card.type === 'domain' ? '‚è±Ô∏è' : 'üéÅ'}\n                </div>\n                \n                <div className=\"card-body\">\n                  {card.type === 'domain' && card.durationMinutes ? (\n                    <div className=\"card-duration\">\n                      {card.durationMinutes} {card.durationMinutes === 1 ? 'minute' : 'minutes'}\n                    </div>\n                  ) : card.type === 'bonusRerolls' && card.bonusRerolls ? (\n                    <div className=\"card-bonus-rerolls\">\n                      +1 re-roll\n                    </div>\n                  ) : null}\n                  \n                  {selectedCard === index && canceledCardIndex !== index && (\n                    <div className=\"card-selected-message\">\n                      {card.type === 'domain' && card.durationMinutes ? (\n                        <div className=\"card-selected-content\">\n                          <div className=\"card-selected-text\">\n                            ‚úì Selected! Unblocked for: <span className=\"card-countdown\">{formatUnblockCountdown(unblockTimeRemaining)}</span>\n                          </div>\n                          <button \n                            className=\"cancel-unblock-card-button\"\n                            onClick={(e) => {\n                              e.stopPropagation();\n                              handleCancelUnblock();\n                            }}\n                            title=\"Cancel this unblock\"\n                          >\n                            Cancel\n                          </button>\n                        </div>\n                      ) : card.type === 'bonusRerolls' && card.bonusRerolls ? (\n                        <>‚úì Bonus applied! You gained 1 re-roll!</>\n                      ) : null}\n                    </div>\n                  )}\n                  \n                  {selectedCard === null && (\n                    <div className=\"card-actions\">\n                      <div className=\"card-click-hint\">\n                        {cardsLocked \n                          ? 'Waiting for timer to reset...'\n                          : 'Click card to select'}\n                      </div>\n                    </div>\n                  )}\n                </div>\n              </div>\n            </div>\n            {selectedCard === null && (\n              <div className=\"card-reroll-section\">\n                <button\n                  onClick={() => rerollCard(index)}\n                  disabled={!canReroll}\n                  className=\"reroll-button\"\n                  title={!canReroll \n                    ? `No re-roll${availableRerolls !== 1 ? 's' : ''} left. Next selection in ${formatTimeRemaining(timeRemaining)}` \n                    : `${availableRerolls} re-roll${availableRerolls !== 1 ? 's' : ''} left`}\n                >\n                  <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\" strokeLinecap=\"round\" strokeLinejoin=\"round\">\n                    <path d=\"M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8\"></path>\n                    <path d=\"M21 3v5h-5\"></path>\n                    <path d=\"M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16\"></path>\n                    <path d=\"M3 21v-5h5\"></path>\n                  </svg>\n                </button>\n              </div>\n            )}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n\n","import React from \"react\";\nimport { Settings } from \"../types\";\n\ninterface BlockedSitesSectionProps {\n  settings: Settings;\n  onSave: (settings: Settings) => Promise<void>;\n}\n\n// Normalize domain for duplicate checking (case-insensitive, remove www)\nfunction normalizeDomainForCheck(domain: string): string {\n  return domain\n    .toLowerCase()\n    .replace(/^https?:\\/\\//i, '')\n    .replace(/\\/.*$/, '')\n    .replace(/^www\\./i, '')\n    .trim();\n}\n\nexport function BlockedSitesSection({ settings, onSave }: BlockedSitesSectionProps) {\n  const [host, setHost] = React.useState(\"\");\n\n  const addHost = async () => {\n    const h = host.trim().replace(/^https?:\\/\\//, \"\").replace(/\\/.*$/, \"\");\n    if (!h) return;\n    \n    // Normalize the input domain for comparison\n    const normalizedInput = normalizeDomainForCheck(h);\n    \n    // Check for duplicates using normalized comparison\n    const isDuplicate = settings.blockedHosts.some(existingHost => \n      normalizeDomainForCheck(existingHost) === normalizedInput\n    );\n    \n    if (isDuplicate) return;\n    \n    // Automatically add 10 minute duration for new domains\n    const newDurations = { ...(settings.domainDurations || {}) };\n    if (!newDurations[h]) {\n      newDurations[h] = [];\n    }\n    // Add default duration (10 min) if it doesn't already exist\n    if (!newDurations[h].includes(10)) {\n      newDurations[h].push(10);\n    }\n    // Sort durations for better UX\n    newDurations[h].sort((a, b) => a - b);\n    \n    await onSave({ \n      ...settings, \n      blockedHosts: [...settings.blockedHosts, h],\n      domainDurations: newDurations\n    });\n    setHost(\"\");\n  };\n\n  const removeHost = async (h: string) => {\n    const newDurations = { ...(settings.domainDurations || {}) };\n    delete newDurations[h];\n    await onSave({\n      ...settings,\n      blockedHosts: settings.blockedHosts.filter(x => x !== h),\n      domainDurations: newDurations\n    });\n  };\n\n  return (\n    <section>\n      <h2>Blocked sites</h2>\n      <div className=\"row\">\n        <input\n          placeholder=\"e.g. twitter.com\"\n          value={host}\n          onChange={e => setHost(e.target.value)}\n        />\n        <button onClick={addHost}>Add</button>\n      </div>\n      <ul className=\"host-list\">\n        {settings.blockedHosts.map(h => {\n          const durations = (settings.domainDurations || {})[h] || [];\n          return (\n            <li key={h} className=\"host-item\">\n              <div className=\"host-header\">\n                <span className=\"host-name\">{h}</span>\n                <button onClick={() => removeHost(h)}>remove</button>\n              </div>\n              <div className=\"durations-section\">\n                <label className=\"durations-label\">Unblock durations (minutes):</label>\n                <div className=\"durations-list\">\n                  {durations.map((dur, idx) => (\n                    <span key={idx} className=\"duration-tag\">\n                      {dur} min\n                      <button\n                        className=\"duration-remove\"\n                        onClick={async () => {\n                          const newDurations = { ...(settings.domainDurations || {}) };\n                          newDurations[h] = durations.filter((_, i) => i !== idx);\n                          if (newDurations[h].length === 0) {\n                            delete newDurations[h];\n                          }\n                          await onSave({ ...settings, domainDurations: newDurations });\n                        }}\n                      >\n                        √ó\n                      </button>\n                    </span>\n                  ))}\n                  <input\n                    type=\"number\"\n                    min=\"1\"\n                    placeholder=\"Add duration\"\n                    className=\"duration-input\"\n                    onKeyDown={async (e) => {\n                      if (e.key === 'Enter') {\n                        const input = e.currentTarget;\n                        const value = parseInt(input.value);\n                        if (value > 0) {\n                          const newDurations = { ...(settings.domainDurations || {}) };\n                          if (!newDurations[h]) {\n                            newDurations[h] = [];\n                          }\n                          // Check if duration already exists - don't add duplicates\n                          if (!newDurations[h].includes(value)) {\n                            newDurations[h] = [...newDurations[h], value];\n                            // Sort durations for better UX\n                            newDurations[h].sort((a, b) => a - b);\n                            await onSave({ ...settings, domainDurations: newDurations });\n                          }\n                          input.value = '';\n                        }\n                      }\n                    }}\n                  />\n                </div>\n              </div>\n            </li>\n          );\n        })}\n      </ul>\n    </section>\n  );\n}\n\n","import React from \"react\";\nimport { Settings, BlockWindow } from \"../types\";\n\nconst DAYS = [\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\"];\n\ninterface TimeWindowsSectionProps {\n  settings: Settings;\n  onSave: (settings: Settings) => Promise<void>;\n}\n\nexport function TimeWindowsSection({ settings, onSave }: TimeWindowsSectionProps) {\n  const addWindow = async () => {\n    const w: BlockWindow = { day: 1, start: \"09:00\", end: \"17:00\" };\n    await onSave({ ...settings, windows: [...settings.windows, w] });\n  };\n\n  const updateWindow = async (idx: number, patch: Partial<BlockWindow>) => {\n    const windows = settings.windows.slice();\n    windows[idx] = { ...windows[idx], ...patch };\n    await onSave({ ...settings, windows });\n  };\n\n  const removeWindow = async (idx: number) => {\n    const windows = settings.windows.slice();\n    windows.splice(idx, 1);\n    await onSave({ ...settings, windows });\n  };\n\n  return (\n    <section>\n      <h2>Time windows</h2>\n      <button onClick={addWindow}>Add window</button>\n      {settings.windows.map((w, i) => (\n        <div key={i} className=\"card\">\n          <label>\n            Day:\n            <select value={w.day} onChange={e => updateWindow(i, { day: Number(e.target.value) })}>\n              {DAYS.map((d, idx) => (\n                <option value={idx} key={idx}>{d}</option>\n              ))}\n            </select>\n          </label>\n          <label>\n            Start:\n            <input type=\"time\" value={w.start} onChange={e => updateWindow(i, { start: e.target.value })} />\n          </label>\n          <label>\n            End:\n            <input type=\"time\" value={w.end} onChange={e => updateWindow(i, { end: e.target.value })} />\n          </label>\n          <button onClick={() => removeWindow(i)}>remove</button>\n        </div>\n      ))}\n    </section>\n  );\n}\n\n","import React from \"react\";\nimport { Settings } from \"../types\";\n\ninterface MasterSwitchSectionProps {\n  settings: Settings;\n  onSave: (settings: Settings) => Promise<void>;\n}\n\nexport function MasterSwitchSection({ settings, onSave }: MasterSwitchSectionProps) {\n  return (\n    <section>\n      <h2>Master switch</h2>\n      <label>\n        <input\n          type=\"checkbox\"\n          checked={settings.enabled}\n          onChange={e => onSave({ ...settings, enabled: e.target.checked })}\n        />\n        Enabled\n      </label>\n    </section>\n  );\n}\n\n","import React from \"react\";\nimport { DEFAULT_SETTINGS } from \"../types\";\nimport { storage } from \"../lib/browser-api\";\n\ninterface ResetSectionProps {\n  onReset: () => Promise<void>;\n}\n\nexport function ResetSection({ onReset }: ResetSectionProps) {\n  const resetToDefaults = async () => {\n    if (confirm('Reset all settings to defaults? This cannot be undone.')) {\n      await storage.sync.remove(\"settings\");\n      await onReset();\n    }\n  };\n\n  return (\n    <section>\n      <h2>Reset</h2>\n      <button onClick={resetToDefaults} className=\"reset-button\">\n        Reset to Defaults\n      </button>\n      <p className=\"reset-description\">\n        This will clear all saved settings and restore defaults.\n      </p>\n    </section>\n  );\n}\n\n","import React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport \"../styles/common.css\";\nimport \"../styles/Options.css\";\nimport { DEFAULT_SETTINGS, Settings } from \"../types\";\nimport { CardGamble } from \"../components/CardGamble\";\nimport { BlockedSitesSection } from \"../components/BlockedSitesSection\";\nimport { TimeWindowsSection } from \"../components/TimeWindowsSection\";\nimport { MasterSwitchSection } from \"../components/MasterSwitchSection\";\nimport { ResetSection } from \"../components/ResetSection\";\nimport { storage, runtime } from \"../lib/browser-api\";\n\nconst STORAGE_KEY = \"settings\";\n\nfunction Options() {\n  const [settings, setSettings] = React.useState<Settings>(DEFAULT_SETTINGS);\n  const [cardGambleResetKey, setCardGambleResetKey] = React.useState(0);\n\n  React.useEffect(() => {\n    (async () => {\n      const { [STORAGE_KEY]: s } = await storage.sync.get(STORAGE_KEY);\n      setSettings({ ...DEFAULT_SETTINGS, ...(s || {}) });\n    })();\n  }, []);\n\n  const save = async (next: Settings) => {\n    setSettings(next);\n    await storage.sync.set({ [STORAGE_KEY]: next });\n  };\n\n  const resetToDefaults = async () => {\n    setSettings(DEFAULT_SETTINGS);\n    // Trigger CardGamble reset by incrementing the key\n    setCardGambleResetKey(prev => prev + 1);\n    // Clear all temporary unblocks\n    try {\n      await runtime.sendMessage({ action: 'clearTemporaryUnblocks' });\n    } catch (error) {\n      console.error('Error clearing temporary unblocks:', error);\n    }\n  };\n\n  return (\n    <div className=\"p\">\n      <h1>Blocker Options</h1>\n\n      {settings.blockedHosts.length > 0 && (\n        <section>\n          <CardGamble \n            domains={settings.blockedHosts} \n            domainDurations={settings.domainDurations || {}}\n            resetKey={cardGambleResetKey}\n          />\n        </section>\n      )}\n\n      <BlockedSitesSection settings={settings} onSave={save} />\n\n      <TimeWindowsSection settings={settings} onSave={save} />\n\n      <MasterSwitchSection settings={settings} onSave={save} />\n\n      <ResetSection onReset={resetToDefaults} />\n    </div>\n  );\n}\n\nReactDOM.createRoot(document.getElementById(\"root\")!).render(<Options />);\n"],"names":["extractHostname","domain","hostname","generateRandomOption","domains","domainDurations","randomIndex","randomDomain","customDurations","unblockMinutes","durationIndex","REROLL_STATE_KEY","DEFAULT_REROLL_RESET_MINUTES","INITIAL_REROLLS","CardGamble","resetKey","cards","setCards","React","showCards","setShowCards","selectedCard","setSelectedCard","animationKey","setAnimationKey","availableRerolls","setAvailableRerolls","rerollResetTime","setRerollResetTime","timeRemaining","setTimeRemaining","isLoadingState","setIsLoadingState","cardsLocked","setCardsLocked","selectedCardExpiresAt","setSelectedCardExpiresAt","unblockTimeRemaining","setUnblockTimeRemaining","canceledCardIndex","setCanceledCardIndex","cardAnimationKeys","setCardAnimationKeys","state","storage","rerollState","now","selectedCardData","response","runtime","normalizedDomain","matchingUnblock","u","error","newCards","prev","initialCards","updateTimer","remaining","interval","rerollCard","cardIndex","newKeys","prevCards","selectCard","card","resetTime","expiresAt","updateCountdown","formatTimeRemaining","ms","totalSeconds","minutes","seconds","formatUnblockCountdown","hours","handleCancelUnblock","canReroll","jsxs","jsx","index","e","Fragment","normalizeDomainForCheck","BlockedSitesSection","settings","onSave","host","setHost","addHost","h","normalizedInput","existingHost","newDurations","a","b","removeHost","x","durations","dur","idx","_","i","input","value","DAYS","TimeWindowsSection","addWindow","w","updateWindow","patch","windows","removeWindow","d","MasterSwitchSection","ResetSection","onReset","resetToDefaults","STORAGE_KEY","Options","setSettings","DEFAULT_SETTINGS","cardGambleResetKey","setCardGambleResetKey","save","next","ReactDOM"],"mappings":"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"}