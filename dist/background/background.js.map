{"version":3,"file":"background.js","sources":["../../src/lib/schedule.ts","../../src/background/background.ts"],"sourcesContent":["import { BlockWindow } from \"../types\";\n\n/** Parse \"HH:MM\" into minutes since midnight. */\nexport function toMinutes(hhmm: string): number {\n  const [h, m] = hhmm.split(\":\").map(Number);\n  return h * 60 + m;\n}\n\n/** Return true if `now` falls within any active window for its local weekday. */\nexport function isWithinAnyWindow(now: Date, windows: BlockWindow[]): boolean {\n  const day = now.getDay(); // 0-6\n  const minutes = now.getHours() * 60 + now.getMinutes();\n  return windows.some(w => {\n    if (w.day !== day) return false;\n    const start = toMinutes(w.start);\n    const end = toMinutes(w.end);\n    // handle both normal and overnight windows\n    if (start <= end) {\n      return minutes >= start && minutes < end;\n    } else {\n      return minutes >= start || minutes < end;\n    }\n  });\n}\n\n/** Find the next boundary time (start or end) after `now`. */\nexport function nextBoundaryAfter(now: Date, windows: BlockWindow[]): Date {\n  const candidates: Date[] = [];\n\n  for (let offset = 0; offset < 8; offset++) {\n    const d = new Date(now);\n    d.setDate(now.getDate() + offset);\n    const day = d.getDay();\n\n    const todays = windows.filter(w => w.day === day);\n    todays.forEach(w => {\n      const start = toMinutes(w.start);\n      const end = toMinutes(w.end);\n\n      const mk = (mins: number) => {\n        const dt = new Date(d);\n        dt.setHours(0, 0, 0, 0);\n        dt.setMinutes(mins);\n        return dt;\n      };\n\n      candidates.push(mk(start));\n      candidates.push(mk(end));\n    });\n  }\n\n  const future = candidates\n    .map(c => ({ c, t: c.getTime() }))\n    .filter(x => x.t > now.getTime())\n    .sort((a, b) => a.t - b.t);\n\n  return future[0]?.c ?? new Date(now.getTime() + 24 * 60 * 60 * 1000);\n}\n","import { DEFAULT_SETTINGS, Settings, TemporaryUnblock } from \"../types\";\nimport { isWithinAnyWindow, nextBoundaryAfter } from \"../lib/schedule\";\n\nconst STORAGE_KEY = \"settings\";\nconst TEMP_UNBLOCKS_KEY = \"temporaryUnblocks\";\nconst ALARM_KEY = \"schedule-boundary\";\nconst CLEANUP_UNBLOCKS_ALARM_KEY = \"cleanup-unblocks\";\nconst REROLL_RESET_ALARM_KEY = \"reroll-reset\";\nconst REROLL_RESET_TIME_KEY = \"rerollResetTime\";\n\n// Debug mode - set to true for verbose logging\nconst DEBUG = true;\n\nfunction debugLog(...args: any[]) {\n  if (DEBUG) {\n    console.log('[Productivity Blocker]', ...args);\n  }\n}\n\nasync function getSettings(): Promise<Settings> {\n  const { [STORAGE_KEY]: s } = await chrome.storage.sync.get(STORAGE_KEY);\n  return { ...DEFAULT_SETTINGS, ...(s || {}) };\n}\n\n// Normalize domain for comparison\nfunction normalizeDomain(domain: string): string {\n  return domain.replace(/^https?:\\/\\//, '').replace(/\\/.*$/, '').replace(/^www\\./, '').toLowerCase();\n}\n\n// Check if a URL matches any blocked host\nfunction isBlockedUrl(url: string, blockedHosts: string[]): boolean {\n  try {\n    const urlObj = new URL(url);\n    const hostname = normalizeDomain(urlObj.hostname);\n    \n    return blockedHosts.some(blockedHost => {\n      const blocked = normalizeDomain(blockedHost);\n      return hostname === blocked || hostname.endsWith('.' + blocked);\n    });\n  } catch {\n    return false;\n  }\n}\n\n// Check if a domain is temporarily unblocked\nasync function isTemporarilyUnblocked(domain: string): Promise<boolean> {\n  try {\n    const { [TEMP_UNBLOCKS_KEY]: unblocks } = await chrome.storage.local.get(TEMP_UNBLOCKS_KEY);\n    if (!unblocks || !Array.isArray(unblocks)) return false;\n    \n    const normalizedDomain = normalizeDomain(domain);\n    const now = Date.now();\n    \n    // Check if domain is in unblocks and not expired\n    return unblocks.some((unblock: TemporaryUnblock) => {\n      const unblockDomain = normalizeDomain(unblock.domain);\n      return (unblockDomain === normalizedDomain || normalizedDomain.endsWith('.' + unblockDomain)) \n        && unblock.expiresAt > now;\n    });\n  } catch {\n    return false;\n  }\n}\n\n// Get all active temporary unblocks\nasync function getActiveUnblocks(): Promise<TemporaryUnblock[]> {\n  try {\n    const { [TEMP_UNBLOCKS_KEY]: unblocks } = await chrome.storage.local.get(TEMP_UNBLOCKS_KEY);\n    if (!unblocks || !Array.isArray(unblocks)) return [];\n    \n    const now = Date.now();\n    return unblocks.filter((unblock: TemporaryUnblock) => unblock.expiresAt > now);\n  } catch {\n    return [];\n  }\n}\n\n// Clean up expired unblocks\nasync function cleanupExpiredUnblocks() {\n  try {\n    const active = await getActiveUnblocks();\n    await chrome.storage.local.set({ [TEMP_UNBLOCKS_KEY]: active });\n    debugLog('Cleaned up expired unblocks. Active unblocks:', active.length);\n  } catch (error) {\n    console.error('Error cleaning up unblocks:', error);\n  }\n}\n\n// Add a temporary unblock\nasync function addTemporaryUnblock(domain: string, expiresAt: number) {\n  try {\n    const active = await getActiveUnblocks();\n    const normalizedDomain = normalizeDomain(domain);\n    \n    // Remove any existing unblock for this domain\n    const filtered = active.filter(u => normalizeDomain(u.domain) !== normalizedDomain);\n    \n    // Add new unblock\n    filtered.push({ domain: normalizedDomain, expiresAt });\n    \n    await chrome.storage.local.set({ [TEMP_UNBLOCKS_KEY]: filtered });\n    debugLog('Added temporary unblock:', domain, 'expires at:', new Date(expiresAt).toISOString());\n  } catch (error) {\n    console.error('Error adding temporary unblock:', error);\n  }\n}\n\n// Close or redirect tabs that are on blocked sites\nasync function closeBlockedTabs(blockedHosts: string[]) {\n  if (!blockedHosts || blockedHosts.length === 0) return;\n  \n  try {\n    const tabs = await chrome.tabs.query({});\n    const tabsToClose: number[] = [];\n    \n    for (const tab of tabs) {\n      if (tab.url && isBlockedUrl(tab.url, blockedHosts)) {\n        // Check if this domain is temporarily unblocked\n        const isUnblocked = await isTemporarilyUnblocked(tab.url);\n        if (!isUnblocked) {\n          tabsToClose.push(tab.id!);\n          debugLog('Closing blocked tab:', tab.url, 'tabId:', tab.id);\n        } else {\n          debugLog('Tab not closed - temporarily unblocked:', tab.url);\n        }\n      }\n    }\n    \n    if (tabsToClose.length > 0) {\n      await chrome.tabs.remove(tabsToClose);\n      debugLog('Closed', tabsToClose.length, 'blocked tab(s)');\n    }\n  } catch (error) {\n    console.error('Error closing blocked tabs:', error);\n  }\n}\n\nasync function setBlockingEnabled(enabled: boolean, hosts: string[]) {\n  debugLog('setBlockingEnabled:', { enabled, hostsCount: hosts.length, hosts });\n  try {\n    if (enabled && hosts.length) {\n      // Close any existing tabs on blocked sites\n      await closeBlockedTabs(hosts);\n      debugLog('Tab closing enabled for hosts:', hosts);\n    } else {\n      debugLog('Tab closing disabled');\n    }\n  } catch (error) {\n    console.error('Error setting blocking state:', error);\n    // Retry once after a short delay\n    setTimeout(async () => {\n      try {\n        if (enabled && hosts.length) {\n          await closeBlockedTabs(hosts);\n          debugLog('Retry successful: tab closing enabled');\n        } else {\n          debugLog('Retry successful: tab closing disabled');\n        }\n      } catch (retryError) {\n        console.error('Retry also failed:', retryError);\n      }\n    }, 100);\n  }\n}\n\nasync function updateBlockingAndAlarm() {\n  try {\n    const settings = await getSettings();\n    const now = new Date();\n\n    const shouldBlock = settings.enabled && isWithinAnyWindow(now, settings.windows);\n    debugLog('updateBlockingAndAlarm:', {\n      enabled: settings.enabled,\n      shouldBlock,\n      blockedHosts: settings.blockedHosts,\n      windows: settings.windows,\n      currentTime: now.toISOString()\n    });\n    \n    await setBlockingEnabled(shouldBlock, settings.blockedHosts);\n\n    // Schedule the next boundary (start or end of a window)\n    const next = nextBoundaryAfter(now, settings.windows);\n    await chrome.alarms.clear(ALARM_KEY);\n    await chrome.alarms.create(ALARM_KEY, { when: next.getTime() });\n    debugLog('Next boundary scheduled for:', new Date(next.getTime()).toISOString());\n  } catch (error) {\n    console.error('Error updating blocking and alarm:', error);\n  }\n}\n\n\n// Fired when the extension is installed or updated\nchrome.runtime.onInstalled.addListener(() => {\n  updateBlockingAndAlarm();\n  chrome.alarms.create(CLEANUP_UNBLOCKS_ALARM_KEY, { periodInMinutes: 1 });\n});\n\n// Fired on startup\nchrome.runtime.onStartup.addListener(() => {\n  updateBlockingAndAlarm();\n  chrome.alarms.create(CLEANUP_UNBLOCKS_ALARM_KEY, { periodInMinutes: 1 });\n});\n\n// Fired when alarms trigger\nchrome.alarms.onAlarm.addListener(async alarm => {\n  if (alarm.name === ALARM_KEY) {\n    updateBlockingAndAlarm();\n  } else if (alarm.name === CLEANUP_UNBLOCKS_ALARM_KEY) {\n    cleanupExpiredUnblocks();\n  } else if (alarm.name === REROLL_RESET_ALARM_KEY) {\n    debugLog('Reroll reset timer expired, showing popup');\n    await showCardPopupOnTabs();\n    // Clear the stored reset time and reroll state\n    await chrome.storage.local.remove(REROLL_RESET_TIME_KEY);\n    await chrome.storage.local.remove('cardGambleRerollState');\n  }\n});\n\n// If user changes settings in options UI, react immediately\nchrome.storage.onChanged.addListener((changes, area) => {\n  if (area === \"sync\" && changes[STORAGE_KEY]) {\n    updateBlockingAndAlarm();\n  }\n});\n\n// Monitor tab updates to catch navigations to blocked sites (handles cache issues)\nchrome.tabs.onUpdated.addListener(async (tabId, changeInfo, tab) => {\n  // Only act when page is fully loaded\n  if (changeInfo.status !== 'complete' || !tab.url) return;\n  \n  try {\n    const settings = await getSettings();\n    const shouldBlock = settings.enabled && isWithinAnyWindow(new Date(), settings.windows);\n    \n    if (shouldBlock && settings.blockedHosts.length > 0) {\n      if (isBlockedUrl(tab.url, settings.blockedHosts)) {\n        // Check if temporarily unblocked\n        const isUnblocked = await isTemporarilyUnblocked(tab.url);\n        if (!isUnblocked) {\n          debugLog('Blocked site detected in tab update:', tab.url);\n          // Close the tab\n          try {\n            await chrome.tabs.remove(tabId);\n            debugLog('Closed blocked tab:', tab.url);\n          } catch (error) {\n            // Tab might already be closed\n            debugLog('Could not close tab (may already be closed):', tab.url);\n          }\n        } else {\n          debugLog('Tab not closed - temporarily unblocked:', tab.url);\n        }\n      }\n    }\n  } catch (error) {\n    console.error('Error in tab update listener:', error);\n  }\n});\n\n// Schedule reroll reset alarm\nasync function scheduleRerollReset(resetTime: number) {\n  await chrome.alarms.clear(REROLL_RESET_ALARM_KEY);\n  await chrome.storage.local.set({ [REROLL_RESET_TIME_KEY]: resetTime });\n  await chrome.alarms.create(REROLL_RESET_ALARM_KEY, { when: resetTime });\n  debugLog('Scheduled reroll reset for:', new Date(resetTime).toISOString());\n}\n\n// Show card popup on all active tabs\nasync function showCardPopupOnTabs() {\n  try {\n    const tabs = await chrome.tabs.query({});\n    const settings = await getSettings();\n    \n    if (!settings.blockedHosts || settings.blockedHosts.length === 0) {\n      debugLog('No blocked hosts, skipping popup');\n      return;\n    }\n\n    // Inject content script into all tabs\n    for (const tab of tabs) {\n      if (tab.id && tab.url && !tab.url.startsWith('chrome://') && !tab.url.startsWith('chrome-extension://')) {\n        try {\n          await chrome.scripting.executeScript({\n            target: { tabId: tab.id },\n            files: ['content/cardPopup.js']\n          });\n          // Send message to show popup\n          await chrome.tabs.sendMessage(tab.id, { action: 'showCardPopup' });\n        } catch (error) {\n          debugLog('Could not inject script into tab:', tab.url, error);\n        }\n      }\n    }\n    debugLog('Card popup shown on all tabs');\n  } catch (error) {\n    console.error('Error showing card popup:', error);\n  }\n}\n\n// Clear all temporary unblocks\nasync function clearAllTemporaryUnblocks() {\n  try {\n    await chrome.storage.local.remove(TEMP_UNBLOCKS_KEY);\n    debugLog('Cleared all temporary unblocks');\n  } catch (error) {\n    console.error('Error clearing temporary unblocks:', error);\n    throw error;\n  }\n}\n\n// Remove a specific temporary unblock\nasync function removeTemporaryUnblock(domain: string) {\n  try {\n    const active = await getActiveUnblocks();\n    const normalizedDomain = normalizeDomain(domain);\n    \n    // Remove the unblock for this domain\n    const filtered = active.filter(u => normalizeDomain(u.domain) !== normalizedDomain);\n    \n    await chrome.storage.local.set({ [TEMP_UNBLOCKS_KEY]: filtered });\n    debugLog('Removed temporary unblock:', domain);\n  } catch (error) {\n    console.error('Error removing temporary unblock:', error);\n    throw error;\n  }\n}\n\n// Handle messages from options page (roulette wheel and card gamble)\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n  if (message.action === 'temporaryUnblock') {\n    addTemporaryUnblock(message.domain, message.expiresAt).then(() => {\n      sendResponse({ success: true });\n      debugLog('Temporary unblock added:', message.domain, 'for', message.durationMinutes, 'minutes');\n    }).catch(error => {\n      console.error('Error handling temporary unblock:', error);\n      sendResponse({ success: false, error: error.message });\n    });\n    return true; // Keep channel open for async response\n  } else if (message.action === 'scheduleRerollReset') {\n    scheduleRerollReset(message.resetTime).then(() => {\n      sendResponse({ success: true });\n    }).catch(error => {\n      console.error('Error scheduling reroll reset:', error);\n      sendResponse({ success: false, error: error.message });\n    });\n    return true;\n  } else if (message.action === 'cancelRerollReset') {\n    chrome.alarms.clear(REROLL_RESET_ALARM_KEY).then(() => {\n      chrome.storage.local.remove(REROLL_RESET_TIME_KEY).then(() => {\n        sendResponse({ success: true });\n        debugLog('Reroll reset alarm canceled');\n      });\n    }).catch(error => {\n      console.error('Error canceling reroll reset:', error);\n      sendResponse({ success: false, error: error.message });\n    });\n    return true;\n  } else if (message.action === 'clearTemporaryUnblocks') {\n    clearAllTemporaryUnblocks().then(() => {\n      sendResponse({ success: true });\n    }).catch(error => {\n      console.error('Error clearing temporary unblocks:', error);\n      sendResponse({ success: false, error: error.message });\n    });\n    return true;\n  } else if (message.action === 'getActiveUnblocks') {\n    getActiveUnblocks().then((unblocks) => {\n      sendResponse({ success: true, unblocks });\n    }).catch(error => {\n      console.error('Error getting active unblocks:', error);\n      sendResponse({ success: false, error: error.message });\n    });\n    return true;\n  } else if (message.action === 'cancelTemporaryUnblock') {\n    removeTemporaryUnblock(message.domain).then(() => {\n      sendResponse({ success: true });\n    }).catch(error => {\n      console.error('Error canceling temporary unblock:', error);\n      sendResponse({ success: false, error: error.message });\n    });\n    return true;\n  }\n});\n\n// Handle extension icon click - open options page\nchrome.action.onClicked.addListener(async () => {\n  try {\n    await chrome.runtime.openOptionsPage();\n    debugLog('Opened options page');\n  } catch (error) {\n    console.error('Error opening options page:', error);\n  }\n});\n\n\n"],"names":["toMinutes","hhmm","h","m","isWithinAnyWindow","now","windows","day","minutes","w","start","end","nextBoundaryAfter","candidates","offset","d","mk","mins","dt","_a","c","x","a","b","STORAGE_KEY","TEMP_UNBLOCKS_KEY","ALARM_KEY","CLEANUP_UNBLOCKS_ALARM_KEY","REROLL_RESET_ALARM_KEY","REROLL_RESET_TIME_KEY","debugLog","args","getSettings","s","DEFAULT_SETTINGS","normalizeDomain","domain","isBlockedUrl","url","blockedHosts","urlObj","hostname","blockedHost","blocked","isTemporarilyUnblocked","unblocks","normalizedDomain","unblock","unblockDomain","getActiveUnblocks","cleanupExpiredUnblocks","active","error","addTemporaryUnblock","expiresAt","filtered","u","closeBlockedTabs","tabs","tabsToClose","tab","setBlockingEnabled","enabled","hosts","retryError","updateBlockingAndAlarm","settings","shouldBlock","next","alarm","showCardPopupOnTabs","changes","area","tabId","changeInfo","scheduleRerollReset","resetTime","clearAllTemporaryUnblocks","removeTemporaryUnblock","message","sender","sendResponse"],"mappings":"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"}