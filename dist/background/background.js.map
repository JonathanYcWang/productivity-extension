{"version":3,"file":"background.js","sources":["../../src/lib/schedule.ts","../../src/background/background.ts"],"sourcesContent":["import { BlockWindow } from \"../types\";\n\n/** Parse \"HH:MM\" into minutes since midnight. */\nexport function toMinutes(hhmm: string): number {\n  const [h, m] = hhmm.split(\":\").map(Number);\n  return h * 60 + m;\n}\n\n/** Return true if `now` falls within any active window for its local weekday. */\nexport function isWithinAnyWindow(now: Date, windows: BlockWindow[]): boolean {\n  const day = now.getDay(); // 0-6\n  const minutes = now.getHours() * 60 + now.getMinutes();\n  return windows.some(w => {\n    if (w.day !== day) return false;\n    const start = toMinutes(w.start);\n    const end = toMinutes(w.end);\n    // handle both normal and overnight windows\n    if (start <= end) {\n      return minutes >= start && minutes < end;\n    } else {\n      return minutes >= start || minutes < end;\n    }\n  });\n}\n\n/** Find the next boundary time (start or end) after `now`. */\nexport function nextBoundaryAfter(now: Date, windows: BlockWindow[]): Date {\n  const candidates: Date[] = [];\n\n  for (let offset = 0; offset < 8; offset++) {\n    const d = new Date(now);\n    d.setDate(now.getDate() + offset);\n    const day = d.getDay();\n\n    const todays = windows.filter(w => w.day === day);\n    todays.forEach(w => {\n      const start = toMinutes(w.start);\n      const end = toMinutes(w.end);\n\n      const mk = (mins: number) => {\n        const dt = new Date(d);\n        dt.setHours(0, 0, 0, 0);\n        dt.setMinutes(mins);\n        return dt;\n      };\n\n      candidates.push(mk(start));\n      candidates.push(mk(end));\n    });\n  }\n\n  const future = candidates\n    .map(c => ({ c, t: c.getTime() }))\n    .filter(x => x.t > now.getTime())\n    .sort((a, b) => a.t - b.t);\n\n  return future[0]?.c ?? new Date(now.getTime() + 24 * 60 * 60 * 1000);\n}\n","import { DEFAULT_SETTINGS, Settings, TemporaryUnblock } from \"../types\";\nimport { isWithinAnyWindow, nextBoundaryAfter } from \"../lib/schedule\";\nimport { storage, alarms, tabs, runtime, scripting, action } from \"../lib/browser-api\";\n\nconst STORAGE_KEY = \"settings\";\nconst TEMP_UNBLOCKS_KEY = \"temporaryUnblocks\";\nconst ALARM_KEY = \"schedule-boundary\";\nconst CLEANUP_UNBLOCKS_ALARM_KEY = \"cleanup-unblocks\";\nconst REROLL_RESET_ALARM_KEY = \"reroll-reset\";\nconst REROLL_RESET_TIME_KEY = \"rerollResetTime\";\n\n// Debug mode - set to true for verbose logging\nconst DEBUG = true;\n\nfunction debugLog(...args: any[]) {\n  if (DEBUG) {\n    try {\n      console.log('[Productivity Blocker]', ...args);\n    } catch (error) {\n      // Fallback if console.log fails\n      try {\n        console.error('[Productivity Blocker]', ...args);\n      } catch (e) {\n        // Ignore if console is completely unavailable\n      }\n    }\n  }\n}\n\n// Log extension initialization\ntry {\n  debugLog('Background script loaded');\n} catch (error) {\n  console.error('Error during background script initialization:', error);\n}\n\nasync function getSettings(): Promise<Settings> {\n  const { [STORAGE_KEY]: s } = await storage.sync.get(STORAGE_KEY);\n  return { ...DEFAULT_SETTINGS, ...(s || {}) };\n}\n\n// Normalize domain for comparison\nfunction normalizeDomain(domain: string): string {\n  return domain.replace(/^https?:\\/\\//, '').replace(/\\/.*$/, '').replace(/^www\\./, '').toLowerCase();\n}\n\n// Check if a URL matches any blocked host\nfunction isBlockedUrl(url: string, blockedHosts: string[]): boolean {\n  try {\n    const urlObj = new URL(url);\n    const hostname = normalizeDomain(urlObj.hostname);\n    \n    return blockedHosts.some(blockedHost => {\n      const blocked = normalizeDomain(blockedHost);\n      return hostname === blocked || hostname.endsWith('.' + blocked);\n    });\n  } catch {\n    return false;\n  }\n}\n\n// Check if a domain is temporarily unblocked\nasync function isTemporarilyUnblocked(domain: string): Promise<boolean> {\n  try {\n    const { [TEMP_UNBLOCKS_KEY]: unblocks } = await storage.local.get(TEMP_UNBLOCKS_KEY);\n    if (!unblocks || !Array.isArray(unblocks)) return false;\n    \n    const normalizedDomain = normalizeDomain(domain);\n    const now = Date.now();\n    \n    // Check if domain is in unblocks and not expired\n    return unblocks.some((unblock: TemporaryUnblock) => {\n      const unblockDomain = normalizeDomain(unblock.domain);\n      return (unblockDomain === normalizedDomain || normalizedDomain.endsWith('.' + unblockDomain)) \n        && unblock.expiresAt > now;\n    });\n  } catch {\n    return false;\n  }\n}\n\n// Get all active temporary unblocks\nasync function getActiveUnblocks(): Promise<TemporaryUnblock[]> {\n  try {\n    const { [TEMP_UNBLOCKS_KEY]: unblocks } = await storage.local.get(TEMP_UNBLOCKS_KEY);\n    if (!unblocks || !Array.isArray(unblocks)) return [];\n    \n    const now = Date.now();\n    return unblocks.filter((unblock: TemporaryUnblock) => unblock.expiresAt > now);\n  } catch {\n    return [];\n  }\n}\n\n// Clean up expired unblocks\nasync function cleanupExpiredUnblocks() {\n  try {\n    const active = await getActiveUnblocks();\n    await storage.local.set({ [TEMP_UNBLOCKS_KEY]: active });\n    debugLog('Cleaned up expired unblocks. Active unblocks:', active.length);\n  } catch (error) {\n    console.error('Error cleaning up unblocks:', error);\n  }\n}\n\n// Add a temporary unblock\nasync function addTemporaryUnblock(domain: string, expiresAt: number) {\n  try {\n    const active = await getActiveUnblocks();\n    const normalizedDomain = normalizeDomain(domain);\n    \n    // Remove any existing unblock for this domain\n    const filtered = active.filter(u => normalizeDomain(u.domain) !== normalizedDomain);\n    \n    // Add new unblock\n    filtered.push({ domain: normalizedDomain, expiresAt });\n    \n    await storage.local.set({ [TEMP_UNBLOCKS_KEY]: filtered });\n    debugLog('Added temporary unblock:', domain, 'expires at:', new Date(expiresAt).toISOString());\n  } catch (error) {\n    console.error('Error adding temporary unblock:', error);\n  }\n}\n\n// Close or redirect tabs that are on blocked sites\nasync function closeBlockedTabs(blockedHosts: string[]) {\n  if (!blockedHosts || blockedHosts.length === 0) return;\n  \n  try {\n    const tabsList = await tabs.query({});\n    const tabsToClose: number[] = [];\n    \n    for (const tab of tabsList) {\n      if (tab.url && isBlockedUrl(tab.url, blockedHosts)) {\n        // Check if this domain is temporarily unblocked\n        const isUnblocked = await isTemporarilyUnblocked(tab.url);\n        if (!isUnblocked) {\n          tabsToClose.push(tab.id!);\n          debugLog('Closing blocked tab:', tab.url, 'tabId:', tab.id);\n        } else {\n          debugLog('Tab not closed - temporarily unblocked:', tab.url);\n        }\n      }\n    }\n    \n    if (tabsToClose.length > 0) {\n      await tabs.remove(tabsToClose);\n      debugLog('Closed', tabsToClose.length, 'blocked tab(s)');\n    }\n  } catch (error) {\n    console.error('Error closing blocked tabs:', error);\n  }\n}\n\nasync function setBlockingEnabled(enabled: boolean, hosts: string[]) {\n  debugLog('setBlockingEnabled:', { enabled, hostsCount: hosts.length, hosts });\n  try {\n    if (enabled && hosts.length) {\n      // Close any existing tabs on blocked sites\n      await closeBlockedTabs(hosts);\n      debugLog('Tab closing enabled for hosts:', hosts);\n    } else {\n      debugLog('Tab closing disabled');\n    }\n  } catch (error) {\n    console.error('Error setting blocking state:', error);\n    // Retry once after a short delay\n    setTimeout(async () => {\n      try {\n        if (enabled && hosts.length) {\n          await closeBlockedTabs(hosts);\n          debugLog('Retry successful: tab closing enabled');\n        } else {\n          debugLog('Retry successful: tab closing disabled');\n        }\n      } catch (retryError) {\n        console.error('Retry also failed:', retryError);\n      }\n    }, 100);\n  }\n}\n\nasync function updateBlockingAndAlarm() {\n  try {\n    const settings = await getSettings();\n    const now = new Date();\n    const mode = settings.mode || 'scheduled';\n\n    let shouldBlock = false;\n    let nextAlarmTime: Date;\n\n    if (mode === 'focus') {\n      // Focus time mode: check if current time is before focusTimeEnd\n      // If paused (focusTimePaused exists), don't block\n      if (settings.focusTimePaused) {\n        // Focus timer is paused (card timer is active)\n        shouldBlock = false;\n        nextAlarmTime = new Date(now.getTime() + 60 * 1000); // Check every minute\n      } else if (settings.focusTimeEnd) {\n        const nowMs = now.getTime();\n        shouldBlock = settings.enabled && nowMs < settings.focusTimeEnd;\n        nextAlarmTime = new Date(Math.min(settings.focusTimeEnd, nowMs + 24 * 60 * 60 * 1000));\n      } else {\n        // No active focus time\n        shouldBlock = false;\n        nextAlarmTime = new Date(now.getTime() + 24 * 60 * 60 * 1000);\n      }\n    } else {\n      // Scheduled mode: use existing window logic\n      shouldBlock = settings.enabled && isWithinAnyWindow(now, settings.windows);\n      nextAlarmTime = nextBoundaryAfter(now, settings.windows);\n    }\n\n    debugLog('updateBlockingAndAlarm:', {\n      mode,\n      enabled: settings.enabled,\n      shouldBlock,\n      blockedHosts: settings.blockedHosts,\n      windows: settings.windows,\n      focusTimeEnd: settings.focusTimeEnd ? new Date(settings.focusTimeEnd).toISOString() : undefined,\n      currentTime: now.toISOString()\n    });\n    \n    await setBlockingEnabled(shouldBlock, settings.blockedHosts);\n\n    // Schedule the next boundary\n    await alarms.clear(ALARM_KEY);\n    await alarms.create(ALARM_KEY, { when: nextAlarmTime.getTime() });\n    debugLog('Next boundary scheduled for:', new Date(nextAlarmTime.getTime()).toISOString());\n  } catch (error) {\n    console.error('Error updating blocking and alarm:', error);\n  }\n}\n\n\n// Fired when the extension is installed or updated\nif (runtime.onInstalled) {\n  runtime.onInstalled.addListener(() => {\n    try {\n      debugLog('Extension installed/updated');\n      updateBlockingAndAlarm().catch(error => {\n        console.error('Error in updateBlockingAndAlarm on install:', error);\n      });\n      alarms.create(CLEANUP_UNBLOCKS_ALARM_KEY, { periodInMinutes: 1 }).catch(error => {\n        console.error('Error creating cleanup alarm:', error);\n      });\n    } catch (error) {\n      console.error('Error in onInstalled listener:', error);\n    }\n  });\n}\n\n// Fired on startup\nif (runtime.onStartup) {\n  runtime.onStartup.addListener(() => {\n    try {\n      debugLog('Extension startup');\n      updateBlockingAndAlarm().catch(error => {\n        console.error('Error in updateBlockingAndAlarm on startup:', error);\n      });\n      alarms.create(CLEANUP_UNBLOCKS_ALARM_KEY, { periodInMinutes: 1 }).catch(error => {\n        console.error('Error creating cleanup alarm on startup:', error);\n      });\n    } catch (error) {\n      console.error('Error in onStartup listener:', error);\n    }\n  });\n}\n\n// Fired when alarms trigger\nif (alarms.onAlarm && 'addListener' in alarms.onAlarm) {\n  alarms.onAlarm.addListener(async (alarm: any) => {\n  if (alarm.name === ALARM_KEY) {\n    updateBlockingAndAlarm();\n  } else if (alarm.name === CLEANUP_UNBLOCKS_ALARM_KEY) {\n    cleanupExpiredUnblocks();\n  } else if (alarm.name === REROLL_RESET_ALARM_KEY) {\n    debugLog('Reroll reset timer expired, showing popup');\n    await showCardPopupOnTabs();\n    // Clear the stored reset time and reroll state\n    await storage.local.remove(REROLL_RESET_TIME_KEY);\n    await storage.local.remove('cardGambleRerollState');\n  }\n  });\n}\n\n// If user changes settings in options UI, react immediately\nif (storage.onChanged) {\n  storage.onChanged.addListener((changes: any, area: string) => {\n    if (area === \"sync\" && changes[STORAGE_KEY]) {\n      updateBlockingAndAlarm();\n    }\n  });\n}\n\n// Monitor tab updates to catch navigations to blocked sites (handles cache issues)\nif (tabs.onUpdated) {\n  tabs.onUpdated.addListener(async (tabId: number, changeInfo: any, tab: any) => {\n  // Only act when page is fully loaded\n  if (changeInfo.status !== 'complete' || !tab.url) return;\n  \n  try {\n    const settings = await getSettings();\n    const mode = settings.mode || 'scheduled';\n    const now = new Date();\n    \n    let shouldBlock = false;\n    if (mode === 'focus') {\n      // Focus time mode: check if current time is before focusTimeEnd\n      // If paused (focusTimePaused exists), don't block\n      if (settings.focusTimePaused) {\n        // Focus timer is paused (card timer is active)\n        shouldBlock = false;\n      } else if (settings.focusTimeEnd) {\n        const nowMs = now.getTime();\n        shouldBlock = settings.enabled && nowMs < settings.focusTimeEnd;\n      }\n    } else {\n      // Scheduled mode: use existing window logic\n      shouldBlock = settings.enabled && isWithinAnyWindow(now, settings.windows);\n    }\n    \n    if (shouldBlock && settings.blockedHosts.length > 0) {\n      if (isBlockedUrl(tab.url, settings.blockedHosts)) {\n        // Check if temporarily unblocked\n        const isUnblocked = await isTemporarilyUnblocked(tab.url);\n        if (!isUnblocked) {\n          debugLog('Blocked site detected in tab update:', tab.url);\n          // Close the tab\n          try {\n            await tabs.remove(tabId);\n            debugLog('Closed blocked tab:', tab.url);\n          } catch (error) {\n            // Tab might already be closed\n            debugLog('Could not close tab (may already be closed):', tab.url);\n          }\n        } else {\n          debugLog('Tab not closed - temporarily unblocked:', tab.url);\n        }\n      }\n    }\n  } catch (error) {\n    console.error('Error in tab update listener:', error);\n  }\n  });\n}\n\n// Schedule reroll reset alarm\nasync function scheduleRerollReset(resetTime: number) {\n  await alarms.clear(REROLL_RESET_ALARM_KEY);\n  await storage.local.set({ [REROLL_RESET_TIME_KEY]: resetTime });\n  await alarms.create(REROLL_RESET_ALARM_KEY, { when: resetTime });\n  debugLog('Scheduled reroll reset for:', new Date(resetTime).toISOString());\n}\n\n// Show card popup on all active tabs\nasync function showCardPopupOnTabs() {\n  try {\n    const tabsList = await tabs.query({});\n    const settings = await getSettings();\n    \n    if (!settings.blockedHosts || settings.blockedHosts.length === 0) {\n      debugLog('No blocked hosts, skipping popup');\n      return;\n    }\n\n    // Inject content script into all tabs\n    for (const tab of tabsList) {\n      const tabUrl = tab.url || '';\n      const isChromeUrl = tabUrl.startsWith('chrome://') || tabUrl.startsWith('chrome-extension://');\n      const isSafariUrl = tabUrl.startsWith('safari-extension://') || tabUrl.startsWith('safari-web-extension://');\n      if (tab.id && tabUrl && !isChromeUrl && !isSafariUrl) {\n        try {\n          await scripting.executeScript({\n            target: { tabId: tab.id },\n            files: ['content/cardPopup.js']\n          });\n          // Send message to show popup\n          await tabs.sendMessage(tab.id, { action: 'showCardPopup' });\n        } catch (error) {\n          debugLog('Could not inject script into tab:', tab.url, error);\n        }\n      }\n    }\n    debugLog('Card popup shown on all tabs');\n  } catch (error) {\n    console.error('Error showing card popup:', error);\n  }\n}\n\n// Clear all temporary unblocks\nasync function clearAllTemporaryUnblocks() {\n  try {\n    await storage.local.remove(TEMP_UNBLOCKS_KEY);\n    debugLog('Cleared all temporary unblocks');\n  } catch (error) {\n    console.error('Error clearing temporary unblocks:', error);\n    throw error;\n  }\n}\n\n// Remove a specific temporary unblock\nasync function removeTemporaryUnblock(domain: string) {\n  try {\n    const active = await getActiveUnblocks();\n    const normalizedDomain = normalizeDomain(domain);\n    \n    // Remove the unblock for this domain\n    const filtered = active.filter(u => normalizeDomain(u.domain) !== normalizedDomain);\n    \n    await storage.local.set({ [TEMP_UNBLOCKS_KEY]: filtered });\n    debugLog('Removed temporary unblock:', domain);\n  } catch (error) {\n    console.error('Error removing temporary unblock:', error);\n    throw error;\n  }\n}\n\n// Handle messages from options page (roulette wheel and card gamble)\nif (runtime.onMessage) {\n  runtime.onMessage.addListener((message: any, sender: any, sendResponse: any) => {\n  if (message.action === 'temporaryUnblock') {\n    addTemporaryUnblock(message.domain, message.expiresAt).then(() => {\n      sendResponse({ success: true });\n      debugLog('Temporary unblock added:', message.domain, 'for', message.durationMinutes, 'minutes');\n    }).catch(error => {\n      console.error('Error handling temporary unblock:', error);\n      sendResponse({ success: false, error: error.message });\n    });\n    return true; // Keep channel open for async response\n  } else if (message.action === 'scheduleRerollReset') {\n    scheduleRerollReset(message.resetTime).then(() => {\n      sendResponse({ success: true });\n    }).catch(error => {\n      console.error('Error scheduling reroll reset:', error);\n      sendResponse({ success: false, error: error.message });\n    });\n    return true;\n  } else if (message.action === 'cancelRerollReset') {\n    alarms.clear(REROLL_RESET_ALARM_KEY).then(() => {\n      storage.local.remove(REROLL_RESET_TIME_KEY).then(() => {\n        sendResponse({ success: true });\n        debugLog('Reroll reset alarm canceled');\n      });\n    }).catch(error => {\n      console.error('Error canceling reroll reset:', error);\n      sendResponse({ success: false, error: error.message });\n    });\n    return true;\n  } else if (message.action === 'clearTemporaryUnblocks') {\n    clearAllTemporaryUnblocks().then(() => {\n      sendResponse({ success: true });\n    }).catch(error => {\n      console.error('Error clearing temporary unblocks:', error);\n      sendResponse({ success: false, error: error.message });\n    });\n    return true;\n  } else if (message.action === 'getActiveUnblocks') {\n    getActiveUnblocks().then((unblocks) => {\n      sendResponse({ success: true, unblocks });\n    }).catch(error => {\n      console.error('Error getting active unblocks:', error);\n      sendResponse({ success: false, error: error.message });\n    });\n    return true;\n  } else if (message.action === 'cancelTemporaryUnblock') {\n    removeTemporaryUnblock(message.domain).then(() => {\n      sendResponse({ success: true });\n    }).catch(error => {\n      console.error('Error canceling temporary unblock:', error);\n      sendResponse({ success: false, error: error.message });\n    });\n    return true;\n  }\n  });\n}\n\n// Handle extension icon click - open options page\nif (action.onClicked) {\n  action.onClicked.addListener(async () => {\n    try {\n      await runtime.openOptionsPage();\n      debugLog('Opened options page');\n    } catch (error) {\n      console.error('Error opening options page:', error);\n    }\n  });\n  debugLog('Registered action.onClicked listener');\n} else {\n  // Fallback: try to access directly\n  try {\n    const rawAction = (action as any)._raw;\n    if (rawAction?.onClicked) {\n      rawAction.onClicked.addListener(async () => {\n        try {\n          await runtime.openOptionsPage();\n          debugLog('Opened options page (via fallback)');\n        } catch (error) {\n          console.error('Error opening options page:', error);\n        }\n      });\n      debugLog('Registered action.onClicked listener (via fallback)');\n    } else {\n      console.warn('action.onClicked is not available - icon click will not open options page');\n    }\n  } catch (error) {\n    console.error('Error setting up action.onClicked listener:', error);\n  }\n}\n\n\n"],"names":["toMinutes","hhmm","h","m","isWithinAnyWindow","now","windows","day","minutes","w","start","end","nextBoundaryAfter","candidates","offset","d","mk","mins","dt","_a","c","x","b","STORAGE_KEY","TEMP_UNBLOCKS_KEY","ALARM_KEY","CLEANUP_UNBLOCKS_ALARM_KEY","REROLL_RESET_ALARM_KEY","REROLL_RESET_TIME_KEY","debugLog","args","error","getSettings","s","storage","DEFAULT_SETTINGS","normalizeDomain","domain","isBlockedUrl","url","blockedHosts","urlObj","hostname","blockedHost","blocked","isTemporarilyUnblocked","unblocks","normalizedDomain","unblock","unblockDomain","getActiveUnblocks","cleanupExpiredUnblocks","active","addTemporaryUnblock","expiresAt","filtered","u","closeBlockedTabs","tabsList","tabs","tabsToClose","tab","setBlockingEnabled","enabled","hosts","retryError","updateBlockingAndAlarm","settings","mode","shouldBlock","nextAlarmTime","nowMs","alarms","runtime","alarm","showCardPopupOnTabs","changes","area","tabId","changeInfo","scheduleRerollReset","resetTime","tabUrl","isChromeUrl","isSafariUrl","scripting","clearAllTemporaryUnblocks","removeTemporaryUnblock","message","sender","sendResponse","action","rawAction"],"mappings":"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"}