import{D as M}from"../assets/types.js";import{r as u,a as i,s,t as f,b as I,c as w}from"../assets/browser-api.js";function y(e){const[o,t]=e.split(":").map(Number);return o*60+t}function v(e,o){const t=e.getDay(),r=e.getHours()*60+e.getMinutes();return o.some(c=>{if(c.day!==t)return!1;const a=y(c.start),l=y(c.end);return a<=l?r>=a&&r<l:r>=a||r<l})}function P(e,o){var c;const t=[];for(let a=0;a<8;a++){const l=new Date(e);l.setDate(e.getDate()+a);const R=l.getDay();o.filter(b=>b.day===R).forEach(b=>{const x=y(b.start),O=y(b.end),L=_=>{const k=new Date(l);return k.setHours(0,0,0,0),k.setMinutes(_),k};t.push(L(x)),t.push(L(O))})}return((c=t.map(a=>({c:a,t:a.getTime()})).filter(a=>a.t>e.getTime()).sort((a,l)=>a.t-l.t)[0])==null?void 0:c.c)??new Date(e.getTime()+24*60*60*1e3)}const E="settings",d="temporaryUnblocks",A="schedule-boundary",T="cleanup-unblocks",g="reroll-reset",C="rerollResetTime";function n(...e){try{console.log("[Productivity Blocker]",...e)}catch{try{console.error("[Productivity Blocker]",...e)}catch{}}}try{n("Background script loaded")}catch(e){console.error("Error during background script initialization:",e)}async function U(){const{[E]:e}=await s.sync.get(E);return{...M,...e||{}}}function p(e){return e.replace(/^https?:\/\//,"").replace(/\/.*$/,"").replace(/^www\./,"").toLowerCase()}function D(e,o){try{const t=new URL(e),r=p(t.hostname);return o.some(c=>{const a=p(c);return r===a||r.endsWith("."+a)})}catch{return!1}}async function B(e){try{const{[d]:o}=await s.local.get(d);if(!o||!Array.isArray(o))return!1;const t=p(e),r=Date.now();return o.some(c=>{const a=p(c.domain);return(a===t||t.endsWith("."+a))&&c.expiresAt>r})}catch{return!1}}async function h(){try{const{[d]:e}=await s.local.get(d);if(!e||!Array.isArray(e))return[];const o=Date.now();return e.filter(t=>t.expiresAt>o)}catch{return[]}}async function K(){try{const e=await h();await s.local.set({[d]:e}),n("Cleaned up expired unblocks. Active unblocks:",e.length)}catch(e){console.error("Error cleaning up unblocks:",e)}}async function W(e,o){try{const t=await h(),r=p(e),c=t.filter(a=>p(a.domain)!==r);c.push({domain:r,expiresAt:o}),await s.local.set({[d]:c}),n("Added temporary unblock:",e,"expires at:",new Date(o).toISOString())}catch(t){console.error("Error adding temporary unblock:",t)}}async function S(e){if(!(!e||e.length===0))try{const o=await f.query({}),t=[];for(const r of o)r.url&&D(r.url,e)&&(await B(r.url)?n("Tab not closed - temporarily unblocked:",r.url):(t.push(r.id),n("Closing blocked tab:",r.url,"tabId:",r.id)));t.length>0&&(await f.remove(t),n("Closed",t.length,"blocked tab(s)"))}catch(o){console.error("Error closing blocked tabs:",o)}}async function H(e,o){n("setBlockingEnabled:",{enabled:e,hostsCount:o.length,hosts:o});try{e&&o.length?(await S(o),n("Tab closing enabled for hosts:",o)):n("Tab closing disabled")}catch(t){console.error("Error setting blocking state:",t),setTimeout(async()=>{try{e&&o.length?(await S(o),n("Retry successful: tab closing enabled")):n("Retry successful: tab closing disabled")}catch(r){console.error("Retry also failed:",r)}},100)}}async function m(){try{const e=await U(),o=new Date,t=e.enabled&&v(o,e.windows);n("updateBlockingAndAlarm:",{enabled:e.enabled,shouldBlock:t,blockedHosts:e.blockedHosts,windows:e.windows,currentTime:o.toISOString()}),await H(t,e.blockedHosts);const r=P(o,e.windows);await i.clear(A),await i.create(A,{when:r.getTime()}),n("Next boundary scheduled for:",new Date(r.getTime()).toISOString())}catch(e){console.error("Error updating blocking and alarm:",e)}}u.onInstalled&&u.onInstalled.addListener(()=>{try{n("Extension installed/updated"),m().catch(e=>{console.error("Error in updateBlockingAndAlarm on install:",e)}),i.create(T,{periodInMinutes:1}).catch(e=>{console.error("Error creating cleanup alarm:",e)})}catch(e){console.error("Error in onInstalled listener:",e)}});u.onStartup&&u.onStartup.addListener(()=>{try{n("Extension startup"),m().catch(e=>{console.error("Error in updateBlockingAndAlarm on startup:",e)}),i.create(T,{periodInMinutes:1}).catch(e=>{console.error("Error creating cleanup alarm on startup:",e)})}catch(e){console.error("Error in onStartup listener:",e)}});i.onAlarm&&"addListener"in i.onAlarm&&i.onAlarm.addListener(async e=>{e.name===A?m():e.name===T?K():e.name===g&&(n("Reroll reset timer expired, showing popup"),await Y(),await s.local.remove(C),await s.local.remove("cardGambleRerollState"))});s.onChanged&&s.onChanged.addListener((e,o)=>{o==="sync"&&e[E]&&m()});f.onUpdated&&f.onUpdated.addListener(async(e,o,t)=>{if(!(o.status!=="complete"||!t.url))try{const r=await U();if(r.enabled&&v(new Date,r.windows)&&r.blockedHosts.length>0&&D(t.url,r.blockedHosts))if(await B(t.url))n("Tab not closed - temporarily unblocked:",t.url);else{n("Blocked site detected in tab update:",t.url);try{await f.remove(e),n("Closed blocked tab:",t.url)}catch{n("Could not close tab (may already be closed):",t.url)}}}catch(r){console.error("Error in tab update listener:",r)}});async function N(e){await i.clear(g),await s.local.set({[C]:e}),await i.create(g,{when:e}),n("Scheduled reroll reset for:",new Date(e).toISOString())}async function Y(){try{const e=await f.query({}),o=await U();if(!o.blockedHosts||o.blockedHosts.length===0){n("No blocked hosts, skipping popup");return}for(const t of e){const r=t.url||"",c=r.startsWith("chrome://")||r.startsWith("chrome-extension://"),a=r.startsWith("safari-extension://")||r.startsWith("safari-web-extension://");if(t.id&&r&&!c&&!a)try{await I.executeScript({target:{tabId:t.id},files:["content/cardPopup.js"]}),await f.sendMessage(t.id,{action:"showCardPopup"})}catch(l){n("Could not inject script into tab:",t.url,l)}}n("Card popup shown on all tabs")}catch(e){console.error("Error showing card popup:",e)}}async function z(){try{await s.local.remove(d),n("Cleared all temporary unblocks")}catch(e){throw console.error("Error clearing temporary unblocks:",e),e}}async function j(e){try{const o=await h(),t=p(e),r=o.filter(c=>p(c.domain)!==t);await s.local.set({[d]:r}),n("Removed temporary unblock:",e)}catch(o){throw console.error("Error removing temporary unblock:",o),o}}u.onMessage&&u.onMessage.addListener((e,o,t)=>{if(e.action==="temporaryUnblock")return W(e.domain,e.expiresAt).then(()=>{t({success:!0}),n("Temporary unblock added:",e.domain,"for",e.durationMinutes,"minutes")}).catch(r=>{console.error("Error handling temporary unblock:",r),t({success:!1,error:r.message})}),!0;if(e.action==="scheduleRerollReset")return N(e.resetTime).then(()=>{t({success:!0})}).catch(r=>{console.error("Error scheduling reroll reset:",r),t({success:!1,error:r.message})}),!0;if(e.action==="cancelRerollReset")return i.clear(g).then(()=>{s.local.remove(C).then(()=>{t({success:!0}),n("Reroll reset alarm canceled")})}).catch(r=>{console.error("Error canceling reroll reset:",r),t({success:!1,error:r.message})}),!0;if(e.action==="clearTemporaryUnblocks")return z().then(()=>{t({success:!0})}).catch(r=>{console.error("Error clearing temporary unblocks:",r),t({success:!1,error:r.message})}),!0;if(e.action==="getActiveUnblocks")return h().then(r=>{t({success:!0,unblocks:r})}).catch(r=>{console.error("Error getting active unblocks:",r),t({success:!1,error:r.message})}),!0;if(e.action==="cancelTemporaryUnblock")return j(e.domain).then(()=>{t({success:!0})}).catch(r=>{console.error("Error canceling temporary unblock:",r),t({success:!1,error:r.message})}),!0});if(w.onClicked)w.onClicked.addListener(async()=>{try{await u.openOptionsPage(),n("Opened options page")}catch(e){console.error("Error opening options page:",e)}}),n("Registered action.onClicked listener");else try{const e=w._raw;e!=null&&e.onClicked?(e.onClicked.addListener(async()=>{try{await u.openOptionsPage(),n("Opened options page (via fallback)")}catch(o){console.error("Error opening options page:",o)}}),n("Registered action.onClicked listener (via fallback)")):console.warn("action.onClicked is not available - icon click will not open options page")}catch(e){console.error("Error setting up action.onClicked listener:",e)}
//# sourceMappingURL=background.js.map
