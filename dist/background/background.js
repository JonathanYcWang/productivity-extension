import{D as I}from"../assets/types.js";import{r as u,a as l,s as i,t as m,b as P,c as E}from"../assets/browser-api.js";function b(e){const[o,t]=e.split(":").map(Number);return o*60+t}function v(e,o){const t=e.getDay(),r=e.getHours()*60+e.getMinutes();return o.some(c=>{if(c.day!==t)return!1;const a=b(c.start),s=b(c.end);return a<=s?r>=a&&r<s:r>=a||r<s})}function K(e,o){var c;const t=[];for(let a=0;a<8;a++){const s=new Date(e);s.setDate(e.getDate()+a);const p=s.getDay();o.filter(g=>g.day===p).forEach(g=>{const R=b(g.start),x=b(g.end),L=_=>{const w=new Date(s);return w.setHours(0,0,0,0),w.setMinutes(_),w};t.push(L(R)),t.push(L(x))})}return((c=t.map(a=>({c:a,t:a.getTime()})).filter(a=>a.t>e.getTime()).sort((a,s)=>a.t-s.t)[0])==null?void 0:c.c)??new Date(e.getTime()+24*60*60*1e3)}const T="settings",d="temporaryUnblocks",A="schedule-boundary",C="cleanup-unblocks",h="reroll-reset",U="rerollResetTime";function n(...e){try{console.log("[Productivity Blocker]",...e)}catch{try{console.error("[Productivity Blocker]",...e)}catch{}}}try{n("Background script loaded")}catch(e){console.error("Error during background script initialization:",e)}async function D(){const{[T]:e}=await i.sync.get(T);return{...I,...e||{}}}function f(e){return e.replace(/^https?:\/\//,"").replace(/\/.*$/,"").replace(/^www\./,"").toLowerCase()}function B(e,o){try{const t=new URL(e),r=f(t.hostname);return o.some(c=>{const a=f(c);return r===a||r.endsWith("."+a)})}catch{return!1}}async function M(e){try{const{[d]:o}=await i.local.get(d);if(!o||!Array.isArray(o))return!1;const t=f(e),r=Date.now();return o.some(c=>{const a=f(c.domain);return(a===t||t.endsWith("."+a))&&c.expiresAt>r})}catch{return!1}}async function y(){try{const{[d]:e}=await i.local.get(d);if(!e||!Array.isArray(e))return[];const o=Date.now();return e.filter(t=>t.expiresAt>o)}catch{return[]}}async function W(){try{const e=await y();await i.local.set({[d]:e}),n("Cleaned up expired unblocks. Active unblocks:",e.length)}catch(e){console.error("Error cleaning up unblocks:",e)}}async function H(e,o){try{const t=await y(),r=f(e),c=t.filter(a=>f(a.domain)!==r);c.push({domain:r,expiresAt:o}),await i.local.set({[d]:c}),n("Added temporary unblock:",e,"expires at:",new Date(o).toISOString())}catch(t){console.error("Error adding temporary unblock:",t)}}async function S(e){if(!(!e||e.length===0))try{const o=await m.query({}),t=[];for(const r of o)r.url&&B(r.url,e)&&(await M(r.url)?n("Tab not closed - temporarily unblocked:",r.url):(t.push(r.id),n("Closing blocked tab:",r.url,"tabId:",r.id)));t.length>0&&(await m.remove(t),n("Closed",t.length,"blocked tab(s)"))}catch(o){console.error("Error closing blocked tabs:",o)}}async function N(e,o){n("setBlockingEnabled:",{enabled:e,hostsCount:o.length,hosts:o});try{e&&o.length?(await S(o),n("Tab closing enabled for hosts:",o)):n("Tab closing disabled")}catch(t){console.error("Error setting blocking state:",t),setTimeout(async()=>{try{e&&o.length?(await S(o),n("Retry successful: tab closing enabled")):n("Retry successful: tab closing disabled")}catch(r){console.error("Retry also failed:",r)}},100)}}async function k(){try{const e=await D(),o=new Date,t=e.mode||"scheduled";let r=!1,c;if(t==="focus")if(e.focusTimePaused)r=!1,c=new Date(o.getTime()+60*1e3);else if(e.focusTimeEnd){const a=o.getTime();r=e.enabled&&a<e.focusTimeEnd,c=new Date(Math.min(e.focusTimeEnd,a+24*60*60*1e3))}else r=!1,c=new Date(o.getTime()+24*60*60*1e3);else r=e.enabled&&v(o,e.windows),c=K(o,e.windows);n("updateBlockingAndAlarm:",{mode:t,enabled:e.enabled,shouldBlock:r,blockedHosts:e.blockedHosts,windows:e.windows,focusTimeEnd:e.focusTimeEnd?new Date(e.focusTimeEnd).toISOString():void 0,currentTime:o.toISOString()}),await N(r,e.blockedHosts),await l.clear(A),await l.create(A,{when:c.getTime()}),n("Next boundary scheduled for:",new Date(c.getTime()).toISOString())}catch(e){console.error("Error updating blocking and alarm:",e)}}u.onInstalled&&u.onInstalled.addListener(()=>{try{n("Extension installed/updated"),k().catch(e=>{console.error("Error in updateBlockingAndAlarm on install:",e)}),l.create(C,{periodInMinutes:1}).catch(e=>{console.error("Error creating cleanup alarm:",e)})}catch(e){console.error("Error in onInstalled listener:",e)}});u.onStartup&&u.onStartup.addListener(()=>{try{n("Extension startup"),k().catch(e=>{console.error("Error in updateBlockingAndAlarm on startup:",e)}),l.create(C,{periodInMinutes:1}).catch(e=>{console.error("Error creating cleanup alarm on startup:",e)})}catch(e){console.error("Error in onStartup listener:",e)}});l.onAlarm&&"addListener"in l.onAlarm&&l.onAlarm.addListener(async e=>{e.name===A?k():e.name===C?W():e.name===h&&(n("Reroll reset timer expired, showing popup"),await z(),await i.local.remove(U),await i.local.remove("cardGambleRerollState"))});i.onChanged&&i.onChanged.addListener((e,o)=>{o==="sync"&&e[T]&&k()});m.onUpdated&&m.onUpdated.addListener(async(e,o,t)=>{if(!(o.status!=="complete"||!t.url))try{const r=await D(),c=r.mode||"scheduled",a=new Date;let s=!1;if(c==="focus"){if(r.focusTimePaused)s=!1;else if(r.focusTimeEnd){const p=a.getTime();s=r.enabled&&p<r.focusTimeEnd}}else s=r.enabled&&v(a,r.windows);if(s&&r.blockedHosts.length>0&&B(t.url,r.blockedHosts))if(await M(t.url))n("Tab not closed - temporarily unblocked:",t.url);else{n("Blocked site detected in tab update:",t.url);try{await m.remove(e),n("Closed blocked tab:",t.url)}catch{n("Could not close tab (may already be closed):",t.url)}}}catch(r){console.error("Error in tab update listener:",r)}});async function Y(e){await l.clear(h),await i.local.set({[U]:e}),await l.create(h,{when:e}),n("Scheduled reroll reset for:",new Date(e).toISOString())}async function z(){try{const e=await m.query({}),o=await D();if(!o.blockedHosts||o.blockedHosts.length===0){n("No blocked hosts, skipping popup");return}for(const t of e){const r=t.url||"",c=r.startsWith("chrome://")||r.startsWith("chrome-extension://"),a=r.startsWith("safari-extension://")||r.startsWith("safari-web-extension://");if(t.id&&r&&!c&&!a)try{await P.executeScript({target:{tabId:t.id},files:["content/cardPopup.js"]}),await m.sendMessage(t.id,{action:"showCardPopup"})}catch(s){n("Could not inject script into tab:",t.url,s)}}n("Card popup shown on all tabs")}catch(e){console.error("Error showing card popup:",e)}}async function j(){try{await i.local.remove(d),n("Cleared all temporary unblocks")}catch(e){throw console.error("Error clearing temporary unblocks:",e),e}}async function G(e){try{const o=await y(),t=f(e),r=o.filter(c=>f(c.domain)!==t);await i.local.set({[d]:r}),n("Removed temporary unblock:",e)}catch(o){throw console.error("Error removing temporary unblock:",o),o}}u.onMessage&&u.onMessage.addListener((e,o,t)=>{if(e.action==="temporaryUnblock")return H(e.domain,e.expiresAt).then(()=>{t({success:!0}),n("Temporary unblock added:",e.domain,"for",e.durationMinutes,"minutes")}).catch(r=>{console.error("Error handling temporary unblock:",r),t({success:!1,error:r.message})}),!0;if(e.action==="scheduleRerollReset")return Y(e.resetTime).then(()=>{t({success:!0})}).catch(r=>{console.error("Error scheduling reroll reset:",r),t({success:!1,error:r.message})}),!0;if(e.action==="cancelRerollReset")return l.clear(h).then(()=>{i.local.remove(U).then(()=>{t({success:!0}),n("Reroll reset alarm canceled")})}).catch(r=>{console.error("Error canceling reroll reset:",r),t({success:!1,error:r.message})}),!0;if(e.action==="clearTemporaryUnblocks")return j().then(()=>{t({success:!0})}).catch(r=>{console.error("Error clearing temporary unblocks:",r),t({success:!1,error:r.message})}),!0;if(e.action==="getActiveUnblocks")return y().then(r=>{t({success:!0,unblocks:r})}).catch(r=>{console.error("Error getting active unblocks:",r),t({success:!1,error:r.message})}),!0;if(e.action==="cancelTemporaryUnblock")return G(e.domain).then(()=>{t({success:!0})}).catch(r=>{console.error("Error canceling temporary unblock:",r),t({success:!1,error:r.message})}),!0});if(E.onClicked)E.onClicked.addListener(async()=>{try{await u.openOptionsPage(),n("Opened options page")}catch(e){console.error("Error opening options page:",e)}}),n("Registered action.onClicked listener");else try{const e=E._raw;e!=null&&e.onClicked?(e.onClicked.addListener(async()=>{try{await u.openOptionsPage(),n("Opened options page (via fallback)")}catch(o){console.error("Error opening options page:",o)}}),n("Registered action.onClicked listener (via fallback)")):console.warn("action.onClicked is not available - icon click will not open options page")}catch(e){console.error("Error setting up action.onClicked listener:",e)}
//# sourceMappingURL=background.js.map
